---
title: Избегайте использования метода Context. Sync в циклах
description: Узнайте, как использовать шаблоны "разделить" и "коррелированные объекты", чтобы избежать контекстного вызова. Синхронизация в цикле.
ms.date: 04/09/2020
localization_priority: Normal
ms.openlocfilehash: 0f967b07b3ccf323321779676021c53c81102f83
ms.sourcegitcommit: 76552b3e5725d9112c772595971b922c295e6b4c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/10/2020
ms.locfileid: "43226014"
---
# <a name="avoid-using-the-contextsync-method-in-loops"></a><span data-ttu-id="0168b-103">Избегайте использования метода Context. Sync в циклах</span><span class="sxs-lookup"><span data-stu-id="0168b-103">Avoid using the context.sync method in loops</span></span>

> [!NOTE]
> <span data-ttu-id="0168b-104">В этой статье предполагается, что вы выходите с первого этапа работы по крайней мере с одним из четырех специфических API&mdash;JavaScript для Office для Excel, Word, OneNote&mdash;и Visio, которые используют пакетную систему для взаимодействия с документом Office.</span><span class="sxs-lookup"><span data-stu-id="0168b-104">This article assumes that you're beyond the beginning stage of working with at least one of the four host-specific Office JavaScript APIs&mdash;for Excel, Word, OneNote, and Visio&mdash;that use a batch system to interact with the Office document.</span></span> <span data-ttu-id="0168b-105">В частности, необходимо знать, что `context.sync` делает вызов, и следует знать, что такое объект Collection.</span><span class="sxs-lookup"><span data-stu-id="0168b-105">In particular, you should know what a call of `context.sync` does and you should know what a collection object is.</span></span> <span data-ttu-id="0168b-106">Если вы не находитесь на этой стадии, начните с [понимания API JavaScript для Office](../develop/understanding-the-javascript-api-for-office.md) и документации, связанной с узлом "зависящий от узла" в этой статье.</span><span class="sxs-lookup"><span data-stu-id="0168b-106">If you're not at that stage, please start with [Understanding the Office JavaScript API](../develop/understanding-the-javascript-api-for-office.md) and the documentation linked to under "host-specific" in that article.</span></span>

<span data-ttu-id="0168b-107">Для некоторых сценариев программирования в надстройках Office, использующих одну из моделей API для конкретных узлов (для Excel, Word, OneNote и Visio), код должен считывать, записывать или обрабатывать свойство из каждого элемента объекта Collection.</span><span class="sxs-lookup"><span data-stu-id="0168b-107">For some programming scenarios in Office Add-ins that use one of the host-specific API models (for Excel, Word, OneNote, and Visio), your code needs to read, write, or process some property from every member of a collection object.</span></span> <span data-ttu-id="0168b-108">Например, надстройка Excel должна получить значения каждой ячейки в определенном столбце таблицы или надстройке Word, которая должна выделять все экземпляры строки в документе.</span><span class="sxs-lookup"><span data-stu-id="0168b-108">For example, an Excel add-in that needs to get the values of every cell in a particular table column or a Word add-in that needs to highlight every instance of a string in the document.</span></span> <span data-ttu-id="0168b-109">Необходимо выполнить итерацию по членам `items` свойства объекта Collection; Однако по соображениям производительности необходимо избегать вызовов `context.sync` в каждой итерации цикла.</span><span class="sxs-lookup"><span data-stu-id="0168b-109">You need to iterate over the members in the `items` property of the collection object; but, for performance reasons, you need to avoid calling `context.sync` in every iteration of the loop.</span></span> <span data-ttu-id="0168b-110">Каждый вызов `context.sync` — это круговой путь к документу Office из надстройки.</span><span class="sxs-lookup"><span data-stu-id="0168b-110">Every call of `context.sync` is a round trip from the add-in to the Office document.</span></span> <span data-ttu-id="0168b-111">Повторные циклы обработки повредит производительность, особенно если надстройка работает в Office в Интернете, так как круговые пути проходят через Интернет.</span><span class="sxs-lookup"><span data-stu-id="0168b-111">Repeated round trips hurt performance, especially if the add-in is running in Office on the web because the round trips go across the internet.</span></span>

> [!NOTE]
> <span data-ttu-id="0168b-112">Во всех примерах в этой `for` статье используются циклы, но описанные в этой статье рекомендации применимы к любому оператору Loop, который может выполнять итерацию по массиву, включая следующие:</span><span class="sxs-lookup"><span data-stu-id="0168b-112">All examples in this article use `for` loops but the practices described apply to any loop statement that can iterate through an array, including the following:</span></span>
>
> - `for`
> - `for of`
> - `while`
> - `do while`
> 
> <span data-ttu-id="0168b-113">Они также применяются к методам массивов, к которым функция передается и применяется к элементам в массиве, включая следующие:</span><span class="sxs-lookup"><span data-stu-id="0168b-113">They also apply to any array method to which a function is passed and applied to the items in the array, including the following:</span></span>
>
> - `Array.every`
> - `Array.forEach`
> - `Array.filter`
> - `Array.find`
> - `Array.findIndex`
> - `Array.map`
> - `Array.reduce`
> - `Array.reduceRight`
> - `Array.some`

## <a name="writing-to-the-document"></a><span data-ttu-id="0168b-114">Запись в документ</span><span class="sxs-lookup"><span data-stu-id="0168b-114">Writing to the document</span></span>

<span data-ttu-id="0168b-115">В самом простом случае вы пишете только для членов объекта Collection, не считывая их свойства.</span><span class="sxs-lookup"><span data-stu-id="0168b-115">In the simplest case, you are only writing to members of a collection object, not reading their properties.</span></span> <span data-ttu-id="0168b-116">Например, приведенный ниже код выделяется желтым цветом каждого экземпляра "The" в документе Word.</span><span class="sxs-lookup"><span data-stu-id="0168b-116">For example, the following code highlights in yellow every instance of "the" in a Word document.</span></span> 

> [!NOTE]
> <span data-ttu-id="0168b-117">Как правило, рекомендуется поместить конечный `context.sync` результат непосредственно перед закрывающим символом "}" в методе host `run` (например `Excel.run`, `Word.run`, и т. д.).</span><span class="sxs-lookup"><span data-stu-id="0168b-117">It is generally a good practice to put have a final `context.sync` just before the closing "}" character of the host `run` method (such as `Excel.run`, `Word.run`, etc.).</span></span> <span data-ttu-id="0168b-118">Это вызвано тем `run` , что метод выполняет скрытый вызов `context.sync` как Последнее, и только если у него есть команды в очереди, которые еще не были синхронизированы.</span><span class="sxs-lookup"><span data-stu-id="0168b-118">This is because the `run` method makes a hidden call of `context.sync` as the last thing it does if, and only if, there are queued commands that have not yet been synchronized.</span></span> <span data-ttu-id="0168b-119">Тот факт, что этот вызов скрыт, может привести к путанице, поэтому рекомендуется добавить явное `context.sync`значение.</span><span class="sxs-lookup"><span data-stu-id="0168b-119">The fact that this call is hidden can be confusing, so we generally recommend that you add the explicit `context.sync`.</span></span> <span data-ttu-id="0168b-120">Тем не менее, если эта статья посвящена минимизации `context.sync`вызовов, на самом деле больше не нужно добавлять полностью ненужный конечный результат `context.sync`.</span><span class="sxs-lookup"><span data-stu-id="0168b-120">However, given that this article is about minimizing calls of `context.sync`, it is actually more confusing to add an entirely unnecessary final `context.sync`.</span></span> <span data-ttu-id="0168b-121">Таким образом, в этой статье мы будем оставить ее, когда в конце файла не будет несинхронизированных команд `run`.</span><span class="sxs-lookup"><span data-stu-id="0168b-121">So, in this article, we leave it out when there are no unsynchronized commands at the end of the `run`.</span></span> 

```javascript
Word.run(async function (context) {
    let startTime, endTime;
    const docBody = context.document.body;

    // search() returns an array of Ranges.
    const searchResults = docBody.search('the', { matchWholeWord: true });
    context.load(searchResults, 'items');
    await context.sync();

    // Record the system time.
    startTime = performance.now();

    for (var i = 0; i < searchResults.items.length; i++) {
      searchResults.items[i].font.highlightColor = '#FFFF00';

      await context.sync(); // SYNCHRONIZE IN EACH ITERATION
    }
    
    // await context.sync(); // SYNCHRONIZE AFTER THE LOOP

    // Record the system time again then calculate how long the operation took.
    endTime = performance.now();
    console.log("The operation took: " + (endTime - startTime) + " milliseconds.");
  })
}
```

<span data-ttu-id="0168b-122">Приведенный выше код занял 1 полную секунду для завершения в документе с 200 экземпляров "The" в Word для Windows.</span><span class="sxs-lookup"><span data-stu-id="0168b-122">The preceding code took 1 full second to complete in a document with 200 instances of "the" in Word on Windows.</span></span> <span data-ttu-id="0168b-123">Но если `await context.sync();` строка внутри цикла заменяется комментарием и та же строка сразу же после этого цикла, операция заняла всего 1/10 секунды.</span><span class="sxs-lookup"><span data-stu-id="0168b-123">But when the `await context.sync();` line inside the loop is commented out and the same line just after the loop is uncommented, the operation took only a 1/10th of a second.</span></span> <span data-ttu-id="0168b-124">В Word в Интернете (с пограничным краем в браузере) для синхронизации в цикле было получено 3 полных секунды и 6/10 десятых секунд с синхронизацией после цикла, в пять раз быстрее.</span><span class="sxs-lookup"><span data-stu-id="0168b-124">In Word on the web (with Edge as the browser), it took 3 full seconds with the synchronization inside the loop and only 6/10ths of a second with the synchronization after the loop, about five times faster.</span></span> <span data-ttu-id="0168b-125">В документе с 2000 экземплярами "The" (в Word в Интернете) 80 секунд с синхронизацией внутри цикла и с синхронизацией в течение всего 4 секунд с синхронизацией после цикла, примерно 20 раз быстрее.</span><span class="sxs-lookup"><span data-stu-id="0168b-125">In a document with 2000 instances of "the", it took (in Word on the web) 80 seconds with the synchronization inside the loop and only 4 seconds with the synchronization after the loop, about 20 times faster.</span></span>

> [!NOTE]
> <span data-ttu-id="0168b-126">Стоит выяснить, будет ли синхронизация по циклу выполняться быстрее, если синхронизация выполнялась параллельно, просто удалив `await` ключевое слово с передней части. `context.sync()`</span><span class="sxs-lookup"><span data-stu-id="0168b-126">It's worth asking whether the synchronize-inside-the-loop version would execute faster if the synchronizations ran concurrently, which could be done by simply removing the `await` keyword from the front of the `context.sync()`.</span></span> <span data-ttu-id="0168b-127">Это приведет к тому, что среда выполнения начнет синхронизацию и сразу запустит следующую итерацию цикла, не дожидаясь завершения синхронизации.</span><span class="sxs-lookup"><span data-stu-id="0168b-127">This would cause the runtime to initiate the synchronization and then immediately start the next iteration of the loop without waiting for the synchronization to complete.</span></span> <span data-ttu-id="0168b-128">Тем не менее, это не так хорошо, как перемещение `context.sync` цикла из цикла по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="0168b-128">However, this is not as good a solution as moving the `context.sync` out of the loop entirely for these reasons:</span></span>
>
> - <span data-ttu-id="0168b-129">Как только команды в пакетном задании синхронизации помещены в очередь, пакетные задания находятся в очереди в Office, но Office не поддерживает более 50 пакетных заданий в очереди.</span><span class="sxs-lookup"><span data-stu-id="0168b-129">Just as the commands in a synchronization batch job are queued, the batch jobs themselves are queued in Office, but Office supports no more than 50 batch jobs in the queue.</span></span> <span data-ttu-id="0168b-130">Дополнительные ошибки триггеров.</span><span class="sxs-lookup"><span data-stu-id="0168b-130">Any more triggers errors.</span></span> <span data-ttu-id="0168b-131">Таким образом, если в цикле больше 50 итераций, существует вероятность превышения размера очереди.</span><span class="sxs-lookup"><span data-stu-id="0168b-131">So, if there are more than 50 iterations in a loop, there is a chance that the queue size is exceeded.</span></span> <span data-ttu-id="0168b-132">Чем больше количество итераций, тем выше вероятность этого.</span><span class="sxs-lookup"><span data-stu-id="0168b-132">The greater the number of iterations, the greater the chance of this happening.</span></span> 
> - <span data-ttu-id="0168b-133">"Параллельно" не означает одновременное.</span><span class="sxs-lookup"><span data-stu-id="0168b-133">"Concurrently" does not mean simultaneously.</span></span> <span data-ttu-id="0168b-134">Выполнение нескольких операций синхронизации по-прежнему займет больше, чем при выполнении одной операции.</span><span class="sxs-lookup"><span data-stu-id="0168b-134">It would still take longer to execute multiple synchronization operations than to execute one.</span></span>
> - <span data-ttu-id="0168b-135">Выполнение параллельных операций не гарантируется в том же порядке, в котором они были запущены.</span><span class="sxs-lookup"><span data-stu-id="0168b-135">Concurrent operations are not guaranteed to complete in the same order in which they started.</span></span> <span data-ttu-id="0168b-136">В предыдущем примере не имеет значения, в каком порядке выделено слово "The", но существуют сценарии, в которых важно, чтобы элементы коллекции обрабатывались по порядку.</span><span class="sxs-lookup"><span data-stu-id="0168b-136">In the preceding example, it doesn't matter what order the  word "the" gets highlighted, but there are scenarios where it's important that the items in the collection be processed in order.</span></span>

## <a name="reading-values-from-the-document-with-the-split-loop-pattern"></a><span data-ttu-id="0168b-137">Считывание значений из документа с помощью шаблона "разделить цикл"</span><span class="sxs-lookup"><span data-stu-id="0168b-137">Reading values from the document with the split loop pattern</span></span>

<span data-ttu-id="0168b-138">Исключение `context.sync`s в цикле становится сложнее, когда код должен *считать* свойство элементов коллекции при обработке каждой из них.</span><span class="sxs-lookup"><span data-stu-id="0168b-138">Avoiding `context.sync`s inside a loop becomes more challenging when the code must *read* a property of the collection items as it processes each one.</span></span> <span data-ttu-id="0168b-139">Предположим, ваш код должен выполнить итерацию всех элементов управления содержимым в документе Word и записать текст первого абзаца, связанного с каждым элементом управления.</span><span class="sxs-lookup"><span data-stu-id="0168b-139">Suppose your code needs to iterate all the content controls in a Word document and log the text of the first paragraph associated with each control.</span></span> <span data-ttu-id="0168b-140">Ваш инстинктс программирования может повлечь за собой циклы по элементам управления, `text` загружать свойство каждого (первого) абзаца, `context.sync` вызывать для заполнения объекта абзаца прокси-сервера текстом из документа, а затем заносить его в журнал.</span><span class="sxs-lookup"><span data-stu-id="0168b-140">Your programming instincts might lead you to loop over the controls, load the `text` property of each (first) paragraph, call `context.sync` to populate the proxy paragraph object with the text from the document, and then log it.</span></span> <span data-ttu-id="0168b-141">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="0168b-141">The following is an example.</span></span>

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load('items');
    await context.sync();

    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      await context.sync();
      console.log(paragraph.text);
    }
});
```

<span data-ttu-id="0168b-142">В этом сценарии, чтобы избежать `context.sync` циклического цикла, следует использовать шаблон, который вызывает шаблон **разбиения** .</span><span class="sxs-lookup"><span data-stu-id="0168b-142">In this scenario, to avoid having a `context.sync` in a loop, you should use a pattern we call the **split loop** pattern.</span></span> <span data-ttu-id="0168b-143">Рассмотрим конкретный пример шаблона, прежде чем приступать к формальному описанию этого шаблона.</span><span class="sxs-lookup"><span data-stu-id="0168b-143">Let's see a concrete example of the pattern before we get to a formal description of it.</span></span> <span data-ttu-id="0168b-144">Ниже показано, как можно применить к предыдущему фрагменту кода шаблон цикла разбиения.</span><span class="sxs-lookup"><span data-stu-id="0168b-144">Here's how the split loop pattern can be applied to the preceding code snippet.</span></span> <span data-ttu-id="0168b-145">Обратите внимание на следующие особенности этого кода:</span><span class="sxs-lookup"><span data-stu-id="0168b-145">Note the following about this code:</span></span>

- <span data-ttu-id="0168b-146">Теперь существует два цикла, и `context.sync` между ними есть два цикла, поэтому в обоих `context.sync` циклах нет.</span><span class="sxs-lookup"><span data-stu-id="0168b-146">There are now two loops and the `context.sync` comes between them, so there's no `context.sync` inside either loop.</span></span>
- <span data-ttu-id="0168b-147">Первый цикл выполняет итерацию элементов в объекте `text` Collection и загружает свойство точно так же, как и исходный цикл, но в первом цикле не удается записать текст абзаца, так как он больше `context.sync` не содержит объект для `text` заполнения свойства `paragraph` прокси-объекта.</span><span class="sxs-lookup"><span data-stu-id="0168b-147">The first loop iterates through the items in the collection object and loads the `text` property just as the original loop did, but the first loop cannot log the paragraph text because it no longer contains a `context.sync` to populate the `text` property of the `paragraph` proxy object.</span></span> <span data-ttu-id="0168b-148">Вместо этого он добавляет `paragraph` объект в массив.</span><span class="sxs-lookup"><span data-stu-id="0168b-148">Instead, it adds the `paragraph` object to an array.</span></span>
- <span data-ttu-id="0168b-149">Второй цикл выполняет итерацию массива, созданного первым циклом, и записывает в `text` журнал все `paragraph` элементы.</span><span class="sxs-lookup"><span data-stu-id="0168b-149">The second loop iterates through the array that was created by the first loop, and logs the `text` of each `paragraph` item.</span></span> <span data-ttu-id="0168b-150">Это возможно `context.sync` , так как между двумя циклами были заполнены все `text` свойства.</span><span class="sxs-lookup"><span data-stu-id="0168b-150">This is possible because the `context.sync` that came between the two loops populated all the `text` properties.</span></span>

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load("items");
    await context.sync();

    const firstParagraphsOfCCs = [];
    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      firstParagraphsOfCCs.push(paragraph);
    }

    await context.sync();

    for (let i = 0; i < firstParagraphsOfCCs.length; i++) {
      console.log(firstParagraphsOfCCs[i].text);
    }
});
```

<span data-ttu-id="0168b-151">В предыдущем примере предлагается следующая процедура для включения цикла, содержащего элемент `context.sync` , в шаблоне Split Loop:</span><span class="sxs-lookup"><span data-stu-id="0168b-151">The preceding example suggests the following procedure for turning a loop that contains a `context.sync` into the split loop pattern:</span></span> 

1. <span data-ttu-id="0168b-152">Замените цикл двумя циклами.</span><span class="sxs-lookup"><span data-stu-id="0168b-152">Replace the loop with two loops.</span></span>
2. <span data-ttu-id="0168b-153">Создайте первый цикл для итерации коллекции и добавьте каждый элемент в массив, а также загрузив все свойства элемента, которые ваш код должен прочесть.</span><span class="sxs-lookup"><span data-stu-id="0168b-153">Create a first loop to iterate over the collection and add each item to an array while also loading any property of the item that your code needs to read.</span></span> 
3. <span data-ttu-id="0168b-154">После первого цикла вызовите метод `context.sync` заполнения прокси-объектов всеми загруженными свойствами.</span><span class="sxs-lookup"><span data-stu-id="0168b-154">Following the first loop, call `context.sync` to populate the proxy objects with any loaded properties.</span></span> 
4. <span data-ttu-id="0168b-155">Выполните цикл `context.sync` со вторым циклом, чтобы выполнить итерацию по массиву, созданному в первом цикле, и считывание загруженных свойств.</span><span class="sxs-lookup"><span data-stu-id="0168b-155">Follow the `context.sync` with a second loop to iterate over the array created in the first loop and read the loaded properties.</span></span>

## <a name="processing-objects-in-the-document-with-the-correlated-objects-pattern"></a><span data-ttu-id="0168b-156">Обработка объектов в документе с помощью шаблона коррелированных объектов</span><span class="sxs-lookup"><span data-stu-id="0168b-156">Processing objects in the document with the correlated objects pattern</span></span>

<span data-ttu-id="0168b-157">Рассмотрим более сложный сценарий, в котором для обработки элементов в коллекции требуются данные, которые не находятся в самих элементах.</span><span class="sxs-lookup"><span data-stu-id="0168b-157">Let's consider a more complex scenario where processing the items in the collection requires data that isn't in the items themselves.</span></span> <span data-ttu-id="0168b-158">Сценарий создает надстройку Word, которая работает с документами, созданными на основе шаблона, с помощью определенного стандартного текста.</span><span class="sxs-lookup"><span data-stu-id="0168b-158">The scenario envisions a Word add-in that operates on documents created from a template with some boilerplate text.</span></span> <span data-ttu-id="0168b-159">Рассеивание в тексте является одним или несколькими экземплярами следующих строк заполнителей: "{координатор}", "{Депути}" и "{руководитель}".</span><span class="sxs-lookup"><span data-stu-id="0168b-159">Scattered in the text are one or more instances of the following placeholder strings: "{Coordinator}", "{Deputy}", and "{Manager}".</span></span> <span data-ttu-id="0168b-160">Надстройка заменяет каждый заполнитель именем определенного пользователя.</span><span class="sxs-lookup"><span data-stu-id="0168b-160">The add-in replaces each placeholder with some person's name.</span></span> <span data-ttu-id="0168b-161">Пользовательский интерфейс надстройки не имеет значения для этой статьи.</span><span class="sxs-lookup"><span data-stu-id="0168b-161">The UI of the add-in is not important to this article.</span></span> <span data-ttu-id="0168b-162">Например, она может иметь область задач с тремя текстовыми полями, каждый из которых снабжен одной из заполнителей.</span><span class="sxs-lookup"><span data-stu-id="0168b-162">For example, it could have a task pane with three text boxes, each labeled with one of the placeholders.</span></span> <span data-ttu-id="0168b-163">Пользователь вводит имя в каждое текстовое поле и нажимает кнопку **заменить** .</span><span class="sxs-lookup"><span data-stu-id="0168b-163">The user enters a name in each text box and then presses a **Replace** button.</span></span> <span data-ttu-id="0168b-164">Обработчик для кнопки создает массив, который сопоставляет имена с заполнителями, а затем заменяет каждый заполнитель на назначенное имя.</span><span class="sxs-lookup"><span data-stu-id="0168b-164">The handler for the button creates an array that maps the names to the placeholders, and then replaces each placeholder with the assigned name.</span></span> 

<span data-ttu-id="0168b-165">Нет необходимости в самом деле создавать надстройку с помощью этого пользовательского интерфейса, чтобы поэкспериментировать с кодом.</span><span class="sxs-lookup"><span data-stu-id="0168b-165">You don't need to actually produce an add-in with this UI to experiment with the code.</span></span> <span data-ttu-id="0168b-166">Для создания прототипа важного кода можно использовать [средство лаборатории скриптов](../overview/explore-with-script-lab.md) .</span><span class="sxs-lookup"><span data-stu-id="0168b-166">You can use the [Script Lab tool](../overview/explore-with-script-lab.md) to prototype the important code.</span></span> <span data-ttu-id="0168b-167">Используйте следующую инструкцию присваивания, чтобы создать массив сопоставления.</span><span class="sxs-lookup"><span data-stu-id="0168b-167">Use the following assignment statement to create the mapping array.</span></span>

```javascript
const jobMapping = [
        { job: "{Coordinator}", person: "Sally" },
        { job: "{Deputy}", person: "Bob" },
        { job: "{Manager}", person: "Kim" }
    ];
```

<span data-ttu-id="0168b-168">В приведенном ниже коде показано, как можно заменить каждый заполнитель с присвоенным ему `context.sync` именем при использовании внутри циклов.</span><span class="sxs-lookup"><span data-stu-id="0168b-168">The following code shows how you might replace each placeholder with its assigned name if you used `context.sync` inside loops.</span></span>

```javascript
Word.run(async (context) => {

    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');

      await context.sync(); 

      for (let j = 0; j < searchResults.items.length; j++) {
        searchResults.items[j].insertText(jobMapping[i].person, Word.InsertLocation.replace);

        await context.sync();
      }
    }
});
```

<span data-ttu-id="0168b-169">В приведенном выше коде есть внешний цикл и внутренний цикл.</span><span class="sxs-lookup"><span data-stu-id="0168b-169">In the preceding code, there is an outer and an inner loop.</span></span> <span data-ttu-id="0168b-170">Каждый из них содержит `context.sync`.</span><span class="sxs-lookup"><span data-stu-id="0168b-170">Each of them contains a `context.sync`.</span></span> <span data-ttu-id="0168b-171">На основе очень первого фрагмента кода в этой статье, вероятно, вы увидите, `context.sync` что во внутреннем цикле можно просто переместиться после внутреннего цикла.</span><span class="sxs-lookup"><span data-stu-id="0168b-171">Based on the very first code snippet in this article, you probably see that the `context.sync` in the inner loop can simply be moved after the inner loop.</span></span> <span data-ttu-id="0168b-172">Но при этом код будет по-прежнему оставаться `context.sync` (два из них на самом деле) во внешнем цикле.</span><span class="sxs-lookup"><span data-stu-id="0168b-172">But that would still leave the code with a `context.sync` (two of them actually) in the outer loop.</span></span> <span data-ttu-id="0168b-173">В приведенном ниже коде показано, как `context.sync` можно удалить из циклов.</span><span class="sxs-lookup"><span data-stu-id="0168b-173">The following code shows how you can remove `context.sync` from the loops.</span></span> <span data-ttu-id="0168b-174">Мы обсудим приведенный ниже код.</span><span class="sxs-lookup"><span data-stu-id="0168b-174">We discuss the code below.</span></span>

```javascript
Word.run(async (context) => {

    const allSearchResults = [];
    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');
      let correlatedSearchResult = {
        rangesMatchingJob: searchResults,
        personAssignedToJob: jobMapping[i].person
      }
      allSearchResults.push(correlatedSearchResult);
    }

    await context.sync()

    for (let i = 0; i < allSearchResults.length; i++) {
      let correlatedObject = allSearchResults[i];

      for (let j = 0; j < correlatedObject.rangesMatchingJob.items.length; j++) {        
        let targetRange = correlatedObject.rangesMatchingJob.items[j];
        let name = correlatedObject.personAssignedToJob;
        targetRange.insertText(name, Word.InsertLocation.replace);
      }
    }

    await context.sync();
});
```

<span data-ttu-id="0168b-175">Обратите внимание на то, что код использует шаблон Loop Split:</span><span class="sxs-lookup"><span data-stu-id="0168b-175">Note the code uses the split loop pattern:</span></span>

- <span data-ttu-id="0168b-176">Внешний цикл из предыдущего примера разбивается на два.</span><span class="sxs-lookup"><span data-stu-id="0168b-176">The outer loop from the preceding example has been split into two.</span></span> <span data-ttu-id="0168b-177">(Во втором цикле есть внутренний цикл, который является ожидаемым, так как код выполняет итерацию по набору заданий (или заполнители) и в пределах этого набора он выполняет итерацию для всех подходящих диапазонов.)</span><span class="sxs-lookup"><span data-stu-id="0168b-177">(The second loop has an inner loop, which is expected because the code is iterating over a set of jobs (or placeholders) and within that set it is iterating over the matching ranges.)</span></span>
- <span data-ttu-id="0168b-178">Каждый главный цикл `context.sync` существует после каждого из них, но `context.sync` не внутри какого-либо цикла.</span><span class="sxs-lookup"><span data-stu-id="0168b-178">There is a `context.sync` after each major loop, but no `context.sync` inside any loop.</span></span> 
- <span data-ttu-id="0168b-179">Второй главный цикл осуществляет итерацию по массиву, созданному в первом цикле.</span><span class="sxs-lookup"><span data-stu-id="0168b-179">The second major loop iterates through an array that is created in the first loop.</span></span>

<span data-ttu-id="0168b-180">Но массив, созданный в первом цикле, *не* содержит только объект Office, так как первый цикл выполнил в разделе [чтение значений из документа с помощью шаблона Loop с разделением](#reading-values-from-the-document-with-the-split-loop-pattern).</span><span class="sxs-lookup"><span data-stu-id="0168b-180">But the array created in the first loop does *not* contain only an Office object as the first loop did in the section [Reading values from the document with the split loop pattern](#reading-values-from-the-document-with-the-split-loop-pattern).</span></span> <span data-ttu-id="0168b-181">Это связано с тем, что некоторые сведения, необходимые для обработки объектов Word Range, не находятся в самих объектах Range, а поступают из `jobMapping` массива.</span><span class="sxs-lookup"><span data-stu-id="0168b-181">This is because some of the information needed to process the Word Range objects is not in the Range objects themselves but instead comes from the `jobMapping` array.</span></span> 

<span data-ttu-id="0168b-182">Таким образом, объекты в массиве, созданные в первом цикле, являются пользовательскими объектами с двумя свойствами.</span><span class="sxs-lookup"><span data-stu-id="0168b-182">So, the objects in the array created in the first loop are custom objects that have two properties.</span></span> <span data-ttu-id="0168b-183">Первый является массивом диапазонов слов, которые совпадают с определенным названием задания (то есть строкой заполнителя), а второй — строкой, которая предоставляет имя пользователя, назначенного заданию.</span><span class="sxs-lookup"><span data-stu-id="0168b-183">The first is an array of Word Ranges that match a specific job title (that is, a placeholder string) and the second is a string that provides the name of the person assigned to the job.</span></span> <span data-ttu-id="0168b-184">Это делает этот цикл простым для чтения и легко читать, так как все сведения, необходимые для обработки заданного диапазона, хранятся в том же пользовательском объекте, который содержит диапазон.</span><span class="sxs-lookup"><span data-stu-id="0168b-184">This makes the final loop easy to write and easy to read because all of the information needed to process a given range is contained in the same custom object that contains the range.</span></span> <span data-ttu-id="0168b-185">Имя, которое должно заменить _ **коррелатедобжект**. ранжесматчингжоб. Items [j]_ , является другим свойством того же объекта: _ **коррелатедобжект**. персонассигнедтожоб_.</span><span class="sxs-lookup"><span data-stu-id="0168b-185">The name that should replace _**correlatedObject**.rangesMatchingJob.items[j]_ is the other property of the same object: _**correlatedObject**.personAssignedToJob_.</span></span> 

<span data-ttu-id="0168b-186">Мы вызываем этот вариант шаблона Loop Loop шаблон **коррелированных объектов** .</span><span class="sxs-lookup"><span data-stu-id="0168b-186">We call this variation of the split loop pattern the **correlated objects** pattern.</span></span> <span data-ttu-id="0168b-187">Общая идея состоит в том, что первый цикл создает массив настраиваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="0168b-187">The general idea is that the first loop creates an array of custom objects.</span></span> <span data-ttu-id="0168b-188">У каждого объекта есть свойство, значение которого равно одному из элементов в объекте коллекции Office (или массив таких элементов).</span><span class="sxs-lookup"><span data-stu-id="0168b-188">Each object has a property whose value is one of the items in an Office collection object (or an array of such items).</span></span> <span data-ttu-id="0168b-189">У пользовательского объекта есть другие свойства, каждый из которых предоставляет сведения, необходимые для обработки объектов Office в последнем цикле.</span><span class="sxs-lookup"><span data-stu-id="0168b-189">The custom object has other properties, each of which provides information needed to process the Office objects in the final loop.</span></span> <span data-ttu-id="0168b-190">В разделе [другие примеры этих шаблонов](#other-examples-of-these-patterns) приведена ссылка на пример, в котором пользовательский объект корреляции имеет более двух свойств.</span><span class="sxs-lookup"><span data-stu-id="0168b-190">See the section [Other examples of these patterns](#other-examples-of-these-patterns) for a link to an example where the custom correlating object has more than two properties.</span></span>

<span data-ttu-id="0168b-191">Еще одно предостережение: иногда требуется несколько циклов, чтобы создать массив настраиваемых объектов корреляции.</span><span class="sxs-lookup"><span data-stu-id="0168b-191">One further caveat: sometimes it takes more than one loop just to create the array of custom correlating objects.</span></span> <span data-ttu-id="0168b-192">Это может произойти, если необходимо прочитать свойство каждого элемента одного объекта Collection Office только для сбора информации, которая будет использоваться для обработки другого объекта Collection.</span><span class="sxs-lookup"><span data-stu-id="0168b-192">This can happen if you need to read a property of each member of one Office collection object just to gather information that will be used to process another collection object.</span></span> <span data-ttu-id="0168b-193">(Например, вашему коду необходимо прочитать заголовки всех столбцов в таблице Excel, так как ваша надстройка будет применять числовой формат к ячейкам некоторых столбцов на основе заголовка столбца). Но вы всегда можете хранить `context.sync`s между циклами, а не в цикле.</span><span class="sxs-lookup"><span data-stu-id="0168b-193">(For example, your code needs to read the titles of all the columns in an Excel table because your add-in is going to apply a number format to the cells of some columns based on that column's title.) But you can always keep the `context.sync`s between the loops, rather than in a loop.</span></span> <span data-ttu-id="0168b-194">В этом разделе представлены [другие примеры этих шаблонов](#other-examples-of-these-patterns) .</span><span class="sxs-lookup"><span data-stu-id="0168b-194">See the section [Other examples of these patterns](#other-examples-of-these-patterns) for an example.</span></span>

## <a name="other-examples-of-these-patterns"></a><span data-ttu-id="0168b-195">Другие примеры этих шаблонов</span><span class="sxs-lookup"><span data-stu-id="0168b-195">Other examples of these patterns</span></span>

- <span data-ttu-id="0168b-196">В качестве простого примера для Excel, использующего `Array.forEach` циклы, ознакомьтесь с принятым ответом на следующий вопрос о переполнении стека: [можно поставить в очередь несколько контекстов. загружать перед контекстным. Синхронизация?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)</span><span class="sxs-lookup"><span data-stu-id="0168b-196">For a very simple example for Excel that uses `Array.forEach` loops, see the accepted answer to this Stack Overflow question: [Is it possible to queue more than one context.load before context.sync?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)</span></span>
- <span data-ttu-id="0168b-197">Простой пример использования `Array.forEach` в Word циклов без синтаксиса, если `async` / `await` он не используется, обратитесь к принятому ответу на этот вопрос: [перебор всех абзацев с элементами управления содержимым с помощью API JavaScript для Office](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).</span><span class="sxs-lookup"><span data-stu-id="0168b-197">For a simple example for Word that uses `Array.forEach` loops and doesn't use `async`/`await` syntax, see the accepted answer to this Stack Overflow question: [Iterating over all paragraphs with content controls with Office JavaScript API](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).</span></span>
- <span data-ttu-id="0168b-198">Пример приложения Word, написанного на TypeScript, приведен в статье пример [средства проверки стилей Angular2 для надстройки Word](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), особенно файл [Word. Document. Service. TS](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts).</span><span class="sxs-lookup"><span data-stu-id="0168b-198">For an example for Word that is written in TypeScript, see the sample [Word Add-in Angular2 Style Checker](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), especially the file [word.document.service.ts](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts).</span></span> <span data-ttu-id="0168b-199">У него есть смесь `for` и `Array.forEach` циклы.</span><span class="sxs-lookup"><span data-stu-id="0168b-199">It has a mixture of `for` and `Array.forEach` loops.</span></span>
- <span data-ttu-id="0168b-200">Для расширенного примера Word импортируйте [его](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) в средство " [Лаборатория скриптов](../overview/explore-with-script-lab.md)".</span><span class="sxs-lookup"><span data-stu-id="0168b-200">For an advanced Word sample, import [this gist](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) into the [Script Lab tool](../overview/explore-with-script-lab.md).</span></span> <span data-ttu-id="0168b-201">В контексте использования этой функции обратитесь к принятому ответу на запрос о переполнении стека, который [не синхронизирован после замены текста](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text).</span><span class="sxs-lookup"><span data-stu-id="0168b-201">For context in using the gist, see the accepted answer to the Stack Overflow question [Document not in sync after replace text](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text).</span></span> <span data-ttu-id="0168b-202">В этом примере создается настраиваемый тип объекта корреляции с тремя свойствами.</span><span class="sxs-lookup"><span data-stu-id="0168b-202">This sample creates a custom correlating object type that has three properties.</span></span> <span data-ttu-id="0168b-203">Он использует всего три цикла для создания массива коррелированных объектов и еще два цикла выполнения завершающей обработки.</span><span class="sxs-lookup"><span data-stu-id="0168b-203">It uses a total of three loops to construct the array of correlated objects, and two more loops to do the final processing.</span></span> <span data-ttu-id="0168b-204">Существует смесь циклов `for` и `Array.forEach` .</span><span class="sxs-lookup"><span data-stu-id="0168b-204">There are a mixture of `for` and `Array.forEach` loops.</span></span>
- <span data-ttu-id="0168b-205">Несмотря на то, что нестрого пример шаблонов разбиения или коррелированных объектов, существует расширенный пример Excel, который показывает, как преобразовать набор значений ячеек в другие валюты только с помощью одного `context.sync`объекта.</span><span class="sxs-lookup"><span data-stu-id="0168b-205">Although not strictly an example of the split loop or correlated objects patterns, there is an advanced Excel sample that shows how to convert a set of cell values to other currencies with just a single `context.sync`.</span></span> <span data-ttu-id="0168b-206">Для этого откройте [средство "Лаборатория скриптов](../overview/explore-with-script-lab.md) " и перейдите к примеру " **Преобразование валюты** ".</span><span class="sxs-lookup"><span data-stu-id="0168b-206">To try it, open the [Script Lab tool](../overview/explore-with-script-lab.md) and navigate to the **Currency Converter** sample.</span></span> 

## <a name="when-should-you-not-use-the-patterns-in-this-article"></a><span data-ttu-id="0168b-207">Когда *не* следует использовать шаблоны, описанные в этой статье?</span><span class="sxs-lookup"><span data-stu-id="0168b-207">When should you *not* use the patterns in this article?</span></span>

<span data-ttu-id="0168b-208">Excel не может считывать более 5 МБ данных при данном вызове `context.sync`.</span><span class="sxs-lookup"><span data-stu-id="0168b-208">Excel cannot read more than 5 MB of data in a given call of `context.sync`.</span></span> <span data-ttu-id="0168b-209">Если это ограничение превышено, возникает ошибка.</span><span class="sxs-lookup"><span data-stu-id="0168b-209">If this limit is exceeded, an error is thrown.</span></span> <span data-ttu-id="0168b-210">(Дополнительные сведения см. в разделе [пределы передаваемых данных Excel](../develop/common-coding-issues.md#excel-data-transfer-limits).) Очень маловероятно, что это приближается к этому ограничению, но если существует вероятность того, что это будет происходить с надстройкой, код *не* должен загружать все данные в один цикл и выполнять цикл с помощью `context.sync`.</span><span class="sxs-lookup"><span data-stu-id="0168b-210">(For more information, see [Excel data transfer limits](../develop/common-coding-issues.md#excel-data-transfer-limits).) It is very rare that this limit is approached, but if there's a chance that this will happen with your add-in, then your code should *not* load all the data in a single loop and follow the loop with a `context.sync`.</span></span> <span data-ttu-id="0168b-211">Но по-прежнему не следует выполнять `context.sync` каждую итерацию цикла над объектом Collection.</span><span class="sxs-lookup"><span data-stu-id="0168b-211">But you still should avoid having a `context.sync` in every iteration of a loop over a collection object.</span></span> <span data-ttu-id="0168b-212">Вместо этого определяйте подмножества элементов в коллекции и циклически перебирает каждое подмножество, используя `context.sync` циклы.</span><span class="sxs-lookup"><span data-stu-id="0168b-212">Instead, define subsets of the items in the collection and loop over each subset in turn, with a `context.sync` between the loops.</span></span> <span data-ttu-id="0168b-213">Это можно структурировать внешним циклом, который выполняет итерацию по подмножествам и содержит `context.sync` все эти внешние итерации.</span><span class="sxs-lookup"><span data-stu-id="0168b-213">You could structure this with an outer loop that iterates over the subsets and contains the `context.sync` in each of these outer iterations.</span></span>
