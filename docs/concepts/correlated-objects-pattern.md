---
title: Избегайте использования метода context.sync в циклах
description: Узнайте, как использовать шаблоны "разделить" и "коррелированные объекты", чтобы избежать контекстного вызова. Синхронизация в цикле.
ms.date: 04/09/2020
localization_priority: Normal
ms.openlocfilehash: bdb7340b999d74baf200aafda2d0f2f41420bd14
ms.sourcegitcommit: be23b68eb661015508797333915b44381dd29bdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2020
ms.locfileid: "44608036"
---
# <a name="avoid-using-the-contextsync-method-in-loops"></a>Избегайте использования метода context.sync в циклах

> [!NOTE]
> В этой статье предполагается, что вы выходите с первого этапа работы по крайней мере с одним из четырех специфических API JavaScript &mdash; для Office для Excel, Word, OneNote и Visio &mdash; , которые используют пакетную систему для взаимодействия с документом Office. В частности, необходимо знать, что `context.sync` делает вызов, и следует знать, что такое объект Collection. Если вы не находитесь на этой стадии, начните с [понимания API JavaScript для Office](../develop/understanding-the-javascript-api-for-office.md) и документации, связанной с узлом "зависящий от узла" в этой статье.

Для некоторых сценариев программирования в надстройках Office, использующих одну из моделей API для конкретных узлов (для Excel, Word, OneNote и Visio), код должен считывать, записывать или обрабатывать свойство из каждого элемента объекта Collection. Например, надстройка Excel должна получить значения каждой ячейки в определенном столбце таблицы или надстройке Word, которая должна выделять все экземпляры строки в документе. Необходимо выполнить итерацию по членам `items` свойства объекта Collection, но в целях повышения производительности необходимо избегать вызовов `context.sync` в каждой итерации цикла. Каждый вызов `context.sync` — это круговой путь к документу Office из надстройки. Повторные циклы обработки повредит производительность, особенно если надстройка работает в Office в Интернете, так как круговые пути проходят через Интернет.

> [!NOTE]
> Во всех примерах в этой статье используются `for` циклы, но описанные в этой статье рекомендации применимы к любому оператору Loop, который может выполнять итерацию по массиву, включая следующие:
>
> - `for`
> - `for of`
> - `while`
> - `do while`
> 
> Они также применяются к методам массивов, к которым функция передается и применяется к элементам в массиве, включая следующие:
>
> - `Array.every`
> - `Array.forEach`
> - `Array.filter`
> - `Array.find`
> - `Array.findIndex`
> - `Array.map`
> - `Array.reduce`
> - `Array.reduceRight`
> - `Array.some`

## <a name="writing-to-the-document"></a>Запись в документ

В самом простом случае вы пишете только для членов объекта Collection, не считывая их свойства. Например, приведенный ниже код выделяется желтым цветом каждого экземпляра "The" в документе Word. 

> [!NOTE]
> Как правило, рекомендуется поместить конечный результат `context.sync` непосредственно перед закрывающим символом "}" в `run` методе Host (например,, и `Excel.run` `Word.run` т. д.). Это вызвано тем, что `run` метод выполняет скрытый вызов `context.sync` как Последнее, и только если у него есть команды в очереди, которые еще не были синхронизированы. Тот факт, что этот вызов скрыт, может привести к путанице, поэтому рекомендуется добавить явное значение `context.sync` . Тем не менее, если эта статья посвящена минимизации вызовов `context.sync` , на самом деле больше не нужно добавлять полностью ненужный конечный результат `context.sync` . Таким образом, в этой статье мы будем оставить ее, когда в конце файла не будет несинхронизированных команд `run` . 

```javascript
Word.run(async function (context) {
    let startTime, endTime;
    const docBody = context.document.body;

    // search() returns an array of Ranges.
    const searchResults = docBody.search('the', { matchWholeWord: true });
    context.load(searchResults, 'items');
    await context.sync();

    // Record the system time.
    startTime = performance.now();

    for (var i = 0; i < searchResults.items.length; i++) {
      searchResults.items[i].font.highlightColor = '#FFFF00';

      await context.sync(); // SYNCHRONIZE IN EACH ITERATION
    }
    
    // await context.sync(); // SYNCHRONIZE AFTER THE LOOP

    // Record the system time again then calculate how long the operation took.
    endTime = performance.now();
    console.log("The operation took: " + (endTime - startTime) + " milliseconds.");
  })
}
```

Приведенный выше код занял 1 полную секунду для завершения в документе с 200 экземпляров "The" в Word для Windows. Но если `await context.sync();` строка внутри цикла заменяется комментарием и та же строка сразу же после этого цикла, операция заняла всего 1/10 секунды. В Word в Интернете (с пограничным краем в браузере) для синхронизации в цикле было получено 3 полных секунды и 6/10 десятых секунд с синхронизацией после цикла, в пять раз быстрее. В документе с 2000 экземплярами "The" (в Word в Интернете) 80 секунд с синхронизацией внутри цикла и с синхронизацией в течение всего 4 секунд с синхронизацией после цикла, примерно 20 раз быстрее.

> [!NOTE]
> Стоит выяснить, будет ли синхронизация по циклу выполняться быстрее, если синхронизация выполнялась параллельно, просто удалив `await` ключевое слово с передней части `context.sync()` . Это приведет к тому, что среда выполнения начнет синхронизацию и сразу запустит следующую итерацию цикла, не дожидаясь завершения синхронизации. Тем не менее, это не так хорошо, как перемещение `context.sync` цикла из цикла по следующим причинам:
>
> - Как только команды в пакетном задании синхронизации помещены в очередь, пакетные задания находятся в очереди в Office, но Office не поддерживает более 50 пакетных заданий в очереди. Дополнительные ошибки триггеров. Таким образом, если в цикле больше 50 итераций, существует вероятность превышения размера очереди. Чем больше количество итераций, тем выше вероятность этого. 
> - "Параллельно" не означает одновременное. Выполнение нескольких операций синхронизации по-прежнему займет больше, чем при выполнении одной операции.
> - Выполнение параллельных операций не гарантируется в том же порядке, в котором они были запущены. В предыдущем примере не имеет значения, в каком порядке выделено слово "The", но существуют сценарии, в которых важно, чтобы элементы коллекции обрабатывались по порядку.

## <a name="reading-values-from-the-document-with-the-split-loop-pattern"></a>Считывание значений из документа с помощью шаблона "разделить цикл"

Исключение `context.sync` s в цикле становится сложнее, когда код должен *считать* свойство элементов коллекции при обработке каждой из них. Предположим, ваш код должен выполнить итерацию всех элементов управления содержимым в документе Word и записать текст первого абзаца, связанного с каждым элементом управления. Ваш инстинктс программирования может повлечь за собой циклы по элементам управления, загружать `text` свойство каждого (первого) абзаца, вызывать `context.sync` для заполнения объекта абзаца прокси-сервера текстом из документа, а затем заносить его в журнал. Ниже приведен пример.

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load('items');
    await context.sync();

    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      await context.sync();
      console.log(paragraph.text);
    }
});
```

В этом сценарии, чтобы избежать `context.sync` циклического цикла, следует использовать шаблон, который вызывает шаблон **разбиения** . Рассмотрим конкретный пример шаблона, прежде чем приступать к формальному описанию этого шаблона. Ниже показано, как можно применить к предыдущему фрагменту кода шаблон цикла разбиения. Обратите внимание на следующие особенности этого кода:

- Теперь существует два цикла `context.sync` , и между ними есть два цикла, поэтому в `context.sync` обоих циклах нет.
- Первый цикл выполняет итерацию элементов в объекте Collection и загружает `text` свойство точно так же, как и исходный цикл, но в первом цикле не удается записать текст абзаца, так как он больше не содержит объект `context.sync` для заполнения `text` свойства `paragraph` прокси-объекта. Вместо этого он добавляет `paragraph` объект в массив.
- Второй цикл выполняет итерацию массива, созданного первым циклом, и записывает в журнал все `text` `paragraph` элементы. Это возможно, так как `context.sync` между двумя циклами были заполнены все `text` Свойства.

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load("items");
    await context.sync();

    const firstParagraphsOfCCs = [];
    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      firstParagraphsOfCCs.push(paragraph);
    }

    await context.sync();

    for (let i = 0; i < firstParagraphsOfCCs.length; i++) {
      console.log(firstParagraphsOfCCs[i].text);
    }
});
```

В предыдущем примере предлагается следующая процедура для включения цикла, содержащего элемент, в `context.sync` шаблоне Split Loop: 

1. Замените цикл двумя циклами.
2. Создайте первый цикл для итерации коллекции и добавьте каждый элемент в массив, а также загрузив все свойства элемента, которые ваш код должен прочесть. 
3. После первого цикла вызовите метод `context.sync` заполнения прокси-объектов всеми загруженными свойствами. 
4. Выполните `context.sync` цикл со вторым циклом, чтобы выполнить итерацию по массиву, созданному в первом цикле, и считывание загруженных свойств.

## <a name="processing-objects-in-the-document-with-the-correlated-objects-pattern"></a>Обработка объектов в документе с помощью шаблона коррелированных объектов

Рассмотрим более сложный сценарий, в котором для обработки элементов в коллекции требуются данные, которые не находятся в самих элементах. Сценарий создает надстройку Word, которая работает с документами, созданными на основе шаблона, с помощью определенного стандартного текста. Рассеивание в тексте является одним или несколькими экземплярами следующих строк заполнителей: "{координатор}", "{Депути}" и "{руководитель}". Надстройка заменяет каждый заполнитель именем определенного пользователя. Пользовательский интерфейс надстройки не имеет значения для этой статьи. Например, она может иметь область задач с тремя текстовыми полями, каждый из которых снабжен одной из заполнителей. Пользователь вводит имя в каждое текстовое поле и нажимает кнопку **заменить** . Обработчик для кнопки создает массив, который сопоставляет имена с заполнителями, а затем заменяет каждый заполнитель на назначенное имя. 

Нет необходимости в самом деле создавать надстройку с помощью этого пользовательского интерфейса, чтобы поэкспериментировать с кодом. Для создания прототипа важного кода можно использовать [средство лаборатории скриптов](../overview/explore-with-script-lab.md) . Используйте следующую инструкцию присваивания, чтобы создать массив сопоставления.

```javascript
const jobMapping = [
        { job: "{Coordinator}", person: "Sally" },
        { job: "{Deputy}", person: "Bob" },
        { job: "{Manager}", person: "Kim" }
    ];
```

В приведенном ниже коде показано, как можно заменить каждый заполнитель с присвоенным ему именем при использовании `context.sync` внутри циклов.

```javascript
Word.run(async (context) => {

    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');

      await context.sync(); 

      for (let j = 0; j < searchResults.items.length; j++) {
        searchResults.items[j].insertText(jobMapping[i].person, Word.InsertLocation.replace);

        await context.sync();
      }
    }
});
```

В приведенном выше коде есть внешний цикл и внутренний цикл. Каждый из них содержит `context.sync` . На основе очень первого фрагмента кода в этой статье, вероятно, вы увидите, что `context.sync` во внутреннем цикле можно просто переместиться после внутреннего цикла. Но при этом код будет по-прежнему оставаться `context.sync` (два из них на самом деле) во внешнем цикле. В приведенном ниже коде показано, как можно удалить `context.sync` из циклов. Мы обсудим приведенный ниже код.

```javascript
Word.run(async (context) => {

    const allSearchResults = [];
    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');
      let correlatedSearchResult = {
        rangesMatchingJob: searchResults,
        personAssignedToJob: jobMapping[i].person
      }
      allSearchResults.push(correlatedSearchResult);
    }

    await context.sync()

    for (let i = 0; i < allSearchResults.length; i++) {
      let correlatedObject = allSearchResults[i];

      for (let j = 0; j < correlatedObject.rangesMatchingJob.items.length; j++) {        
        let targetRange = correlatedObject.rangesMatchingJob.items[j];
        let name = correlatedObject.personAssignedToJob;
        targetRange.insertText(name, Word.InsertLocation.replace);
      }
    }

    await context.sync();
});
```

Обратите внимание на то, что код использует шаблон Loop Split:

- Внешний цикл из предыдущего примера разбивается на два. (Во втором цикле есть внутренний цикл, который является ожидаемым, так как код выполняет итерацию по набору заданий (или заполнители) и в пределах этого набора он выполняет итерацию для всех подходящих диапазонов.)
- `context.sync`Каждый главный цикл существует после каждого из них, но не `context.sync` внутри какого-либо цикла. 
- Второй главный цикл осуществляет итерацию по массиву, созданному в первом цикле.

Но массив, созданный в первом цикле, *не* содержит только объект Office, так как первый цикл выполнил в разделе [чтение значений из документа с помощью шаблона Loop с разделением](#reading-values-from-the-document-with-the-split-loop-pattern). Это связано с тем, что некоторые сведения, необходимые для обработки объектов Word Range, не находятся в самих объектах Range, а поступают из `jobMapping` массива. 

Таким образом, объекты в массиве, созданные в первом цикле, являются пользовательскими объектами с двумя свойствами. Первый является массивом диапазонов слов, которые совпадают с определенным названием задания (то есть строкой заполнителя), а второй — строкой, которая предоставляет имя пользователя, назначенного заданию. Это делает этот цикл простым для чтения и легко читать, так как все сведения, необходимые для обработки заданного диапазона, хранятся в том же пользовательском объекте, который содержит диапазон. Имя, которое должно заменить _ **коррелатедобжект**. ранжесматчингжоб. Items [j]_ , является другим свойством того же объекта: _ **коррелатедобжект**. персонассигнедтожоб_. 

Мы вызываем этот вариант шаблона Loop Loop шаблон **коррелированных объектов** . Общая идея состоит в том, что первый цикл создает массив настраиваемых объектов. У каждого объекта есть свойство, значение которого равно одному из элементов в объекте коллекции Office (или массив таких элементов). У пользовательского объекта есть другие свойства, каждый из которых предоставляет сведения, необходимые для обработки объектов Office в последнем цикле. В разделе [другие примеры этих шаблонов](#other-examples-of-these-patterns) приведена ссылка на пример, в котором пользовательский объект корреляции имеет более двух свойств.

Еще одно предостережение: иногда требуется несколько циклов, чтобы создать массив настраиваемых объектов корреляции. Это может произойти, если необходимо прочитать свойство каждого элемента одного объекта Collection Office только для сбора информации, которая будет использоваться для обработки другого объекта Collection. (Например, вашему коду необходимо прочитать заголовки всех столбцов в таблице Excel, так как ваша надстройка будет применять числовой формат к ячейкам некоторых столбцов на основе заголовка столбца). Но вы всегда можете хранить `context.sync` s между циклами, а не в цикле. В этом разделе представлены [другие примеры этих шаблонов](#other-examples-of-these-patterns) .

## <a name="other-examples-of-these-patterns"></a>Другие примеры этих шаблонов

- В качестве простого примера для Excel, использующего `Array.forEach` циклы, ознакомьтесь с принятым ответом на следующий вопрос о переполнении стека: [можно поставить в очередь несколько контекстов. загружать перед контекстным. Синхронизация?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)
- Простой пример использования `Array.forEach` в Word циклов без синтаксиса, если он не используется `async` / `await` , обратитесь к принятому ответу на этот вопрос: [перебор всех абзацев с элементами управления содержимым с помощью API JavaScript для Office](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).
- Пример приложения Word, написанного на TypeScript, приведен в статье пример [средства проверки стилей Angular2 для надстройки Word](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), особенно файл [Word. Document. Service. TS](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts). У него есть смесь `for` и `Array.forEach` циклы.
- Для расширенного примера Word импортируйте [его](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) в средство " [Лаборатория скриптов](../overview/explore-with-script-lab.md)". В контексте использования этой функции обратитесь к принятому ответу на запрос о переполнении стека, который [не синхронизирован после замены текста](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text). В этом примере создается настраиваемый тип объекта корреляции с тремя свойствами. Он использует всего три цикла для создания массива коррелированных объектов и еще два цикла выполнения завершающей обработки. Существует смесь `for` `Array.forEach` циклов и.
- Несмотря на то, что нестрого пример шаблонов разбиения или коррелированных объектов, существует расширенный пример Excel, который показывает, как преобразовать набор значений ячеек в другие валюты только с помощью одного объекта `context.sync` . Для этого откройте [средство "Лаборатория скриптов](../overview/explore-with-script-lab.md) " и перейдите к примеру " **Преобразование валюты** ". 

## <a name="when-should-you-not-use-the-patterns-in-this-article"></a>Когда *не* следует использовать шаблоны, описанные в этой статье?

Excel не может считывать более 5 МБ данных при данном вызове `context.sync` . Если это ограничение превышено, возникает ошибка. (Дополнительные сведения см. в разделе [пределы передаваемых данных Excel](../develop/common-coding-issues.md#excel-data-transfer-limits).) Очень маловероятно, что это приближается к этому ограничению, но если существует вероятность того, что это будет происходить с надстройкой, код *не* должен загружать все данные в один цикл и выполнять цикл с помощью `context.sync` . Но по-прежнему не следует выполнять `context.sync` каждую итерацию цикла над объектом Collection. Вместо этого определяйте подмножества элементов в коллекции и циклически перебирает каждое подмножество, используя `context.sync` циклы. Это можно структурировать внешним циклом, который выполняет итерацию по подмножествам и содержит `context.sync` все эти внешние итерации.
