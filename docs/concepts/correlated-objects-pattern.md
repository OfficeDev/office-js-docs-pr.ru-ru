---
title: Избегайте использования метода context.sync в циклах
description: Узнайте, как использовать раздельный цикл и сопоставленные шаблоны объектов, чтобы не вызывать context.sync в цикле.
ms.date: 07/08/2021
ms.localizationpriority: medium
ms.openlocfilehash: 3a8e726eccb88e7df47d4a881bc9bb724c265bed
ms.sourcegitcommit: 1306faba8694dea203373972b6ff2e852429a119
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2021
ms.locfileid: "59150818"
---
# <a name="avoid-using-the-contextsync-method-in-loops"></a>Избегайте использования метода context.sync в циклах

> [!NOTE]
> В этой статье предполагается, что вы не на самом начале работы по крайней мере с одним из четырех API javaScript Office для Excel, Word, OneNote и Visio, которые используют пакетную систему для взаимодействия с Office &mdash; &mdash; документом. В частности, необходимо знать, что такое вызов, и знать, что такое `context.sync` объект коллекции. Если вы еще не на этом этапе, начните с Office [API JavaScript](../develop/understanding-the-javascript-api-for-office.md) и документации, связанной с "конкретным приложением" в этой статье.

Для некоторых сценариев программирования в Office надстройки, которые используют одну из моделей API, определенных приложениям (для Excel, Word, OneNote и Visio), коду необходимо прочитать, написать или обработать некоторые свойства от каждого члена объекта коллекции. Например, надстройка Excel, которая должна получать значения каждой ячейки в определенном столбце таблицы или надстройку Word, которая должна выделить каждый экземпляр строки в документе. Необходимо итерировать над участниками в свойстве объекта коллекции; но по соображениям производительности следует избегать вызовов во всех `items` `context.sync` итерациях цикла. Каждый вызов `context.sync` — это круговая поездка из надстройки в Office документа. Повторяемая круговая поездка повредит производительности, особенно если надстройка работает в Office в Интернете, так как круглая поездка идет через Интернет.

> [!NOTE]
> Во всех примерах этой статьи используются циклы, но описанные практики применимы к любому заявлению цикла, которое может итерировать через массив, включая `for` следующие:
>
> - `for`
> - `for of`
> - `while`
> - `do while`
> 
> Они также применяются к любому методу массива, к которому функция передается и применяется к элементу массива, включая следующие:
>
> - `Array.every`
> - `Array.forEach`
> - `Array.filter`
> - `Array.find`
> - `Array.findIndex`
> - `Array.map`
> - `Array.reduce`
> - `Array.reduceRight`
> - `Array.some`

## <a name="writing-to-the-document"></a>Запись в документ

В простейшем случае вы пишете только членам объекта коллекции, не читая их свойства. Например, следующий код выделяет желтым цветом каждый экземпляр "" в документе Word.

> [!NOTE]
> Как правило, перед закрытием "}" символа метода приложения (например, и т. д.) необходимо поставить `context.sync` `run` `Excel.run` `Word.run` окончательный результат. Это происходит потому, что метод делает скрытый вызов как последнее, что он делает, если, и только если есть очереди команд, которые еще не `run` `context.sync` были синхронизированы. Тот факт, что этот вызов скрыт, может привести к путанице, поэтому обычно рекомендуется добавить явный `context.sync` . Однако, учитывая, что в этой статье речь идет о минимизации вызовов, это на самом деле более запутанным, чтобы добавить совершенно `context.sync` ненужный окончательный `context.sync` . Таким образом, в этой статье мы оставьте его, когда нет несинхронизированных команд в конце `run` .

```javascript
Word.run(async function (context) {
    let startTime, endTime;
    const docBody = context.document.body;

    // search() returns an array of Ranges.
    const searchResults = docBody.search('the', { matchWholeWord: true });
    context.load(searchResults, 'items');
    await context.sync();

    // Record the system time.
    startTime = performance.now();

    for (var i = 0; i < searchResults.items.length; i++) {
      searchResults.items[i].font.highlightColor = '#FFFF00';

      await context.sync(); // SYNCHRONIZE IN EACH ITERATION
    }
    
    // await context.sync(); // SYNCHRONIZE AFTER THE LOOP

    // Record the system time again then calculate how long the operation took.
    endTime = performance.now();
    console.log("The operation took: " + (endTime - startTime) + " milliseconds.");
  })
}
```

Предыдущий код занял 1 полную секунду для завершения в документе с 200 экземплярами "" в Word на Windows. Но когда строка внутри цикла комментируется и одна и та же строка сразу после того, как цикл некомментационный, операция занимает только `await context.sync();` 1/10 секунды. В Word в Интернете (с edge в качестве браузера) потребовалось 3 полных секунды с синхронизацией внутри цикла и только 6/10ths секунды с синхронизацией после цикла, примерно в пять раз быстрее. В документе с 2000 экземплярами "the" потребовалось (в Word в Интернете) 80 секунд с синхронизацией внутри цикла и только 4 секунды с синхронизацией после цикла, примерно в 20 раз быстрее.

> [!NOTE]
> Стоит задаться вопросом, будет ли синхронизация внутри цикла выполняться быстрее, если синхронизация выполняется параллельно, что можно сделать, просто удалив ключевое слово с передней панели `await` `context.sync()` . Это приведет к тому, что время выполнения инициирует синхронизацию, а затем сразу же запустит следующую итерацию цикла, не дожидаясь завершения синхронизации. Однако это решение не так хорошо, как перемещение из цикла полностью по `context.sync` этим причинам.
>
> - Так же, как команды в пакетном задании синхронизации стоят в очереди, сами пакетные задания стоят в очереди в Office, но Office поддерживает не более 50 пакетных заданий в очереди. Еще больше вызывает ошибки. Таким образом, если в цикле находится более 50 итераций, существует вероятность превышения размера очереди. Чем больше количество итераций, тем больше вероятность этого. 
> - "Одновременно" не означает одновременно. Выполнение нескольких операций синхронизации по-прежнему займет больше времени, чем одно.
> - Одновечерные операции не гарантируются для выполнения в том же порядке, в котором они были запущены. В предыдущем примере неважно, какой порядок выделяет слово "the", но существуют сценарии, в которых важно, чтобы элементы в коллекции обрабатывались в порядке.

## <a name="read-values-from-the-document-with-the-split-loop-pattern"></a>Чтение значений из документа с шаблоном раздельного цикла

Избежать s внутри цикла становится все сложнее, когда код должен прочитать свойство элементов коллекции по мере обработки `context.sync` каждого из них.  Предположим, что коду необходимо итерировать все элементы управления контентом в документе Word и войти в текст первого абзаца, связанного с каждым элементом управления. Ваши инстинкты программирования могут привести к циклу управления, загрузке свойства каждого (первого) абзаца, вызову для заполнения объекта прокси-абзаца текстом из документа, а затем войти в `text` `context.sync` него. Ниже приведен пример.

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load('items');
    await context.sync();

    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      await context.sync();
      console.log(paragraph.text);
    }
});
```

В этом сценарии, чтобы избежать использования цикла, следует использовать шаблон, который мы называем `context.sync` **шаблоном раздельного цикла.** Давайте рассмотрим конкретный пример шаблона, прежде чем мы примем официальное описание этого шаблона. Вот как шаблон раздельного цикла можно применить к предыдущему фрагменту кода. Обратите внимание на указанные ниже аспекты этого кода.

- В настоящее время существует два цикла, и между ними происходит, поэтому внутри них нет `context.sync` `context.sync` ни одной петли.
- Первый цикл итерирует элементы в объекте коллекции и загружает свойство так же, как и исходный цикл, но первый цикл не может войти в текст абзаца, так как он больше не содержит свойства `text` `context.sync` прокси-объекта. `text` `paragraph` Вместо этого объект `paragraph` добавляется в массив.
- Второй цикл итерирует массив, созданный первым циклом, и регистрирует `text` каждый `paragraph` элемент. Это возможно, так как между двумя циклами заполняются `context.sync` все `text` свойства.

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load("items");
    await context.sync();

    const firstParagraphsOfCCs = [];
    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      firstParagraphsOfCCs.push(paragraph);
    }

    await context.sync();

    for (let i = 0; i < firstParagraphsOfCCs.length; i++) {
      console.log(firstParagraphsOfCCs[i].text);
    }
});
```

В предыдущем примере предлагается следующая процедура превращения цикла, содержающего шаблон `context.sync` раздельного цикла.

1. Замените цикл двумя циклами.
2. Создайте первый цикл итерации над коллекцией и добавьте каждый элемент в массив, а также загрузите любое свойство элемента, который необходимо прочитать коду.
3. После первого цикла необходимо вызвать заполнение объектов прокси с `context.sync` любыми загруженными свойствами.
4. Выполните второй цикл, чтобы итерировать массив, созданный в первом цикле, и прочитать `context.sync` загруженные свойства.

## <a name="process-objects-in-the-document-with-the-correlated-objects-pattern"></a>Обработка объектов в документе с сопоставлением шаблона объектов

Рассмотрим более сложный сценарий, при котором обработка элементов в коллекции требует данных, которых нет в самих элементов. Сценарий предполагает надстройки Word, которая работает на документах, созданных из шаблона с некоторым шаблонным текстом. В тексте рассеян один или несколько экземпляров строки следующих задатков: "{Coordinator}", "{Deputy}" и "{Manager}". Надстройка заменяет каждого замещаемого лица именем определенного человека. Пользовательский интерфейс надстройки не важен для этой статьи. Например, в нем может быть области задач с тремя текстовыми полями, каждая из которых помечена одним из держателей. Пользователь вводит имя в каждом текстовом окне, а затем нажмет кнопку **Заменить.** Обработчик кнопки создает массив, который совмещает имена с держателями, а затем заменяет каждого держателя на назначенное имя.

Чтобы поэкспериментировать с кодом, не нужно создавать надстройку с этим пользовательским интерфейсом. Вы можете использовать Script Lab [для](../overview/explore-with-script-lab.md) прототипа важного кода. Чтобы создать массив сопоставления, используйте следующее утверждение назначения.

```javascript
const jobMapping = [
        { job: "{Coordinator}", person: "Sally" },
        { job: "{Deputy}", person: "Bob" },
        { job: "{Manager}", person: "Kim" }
    ];
```

В следующем коде показано, как можно заменить каждого держателя на назначенное имя, если вы использовали `context.sync` внутренние циклы.

```javascript
Word.run(async (context) => {

    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');

      await context.sync(); 

      for (let j = 0; j < searchResults.items.length; j++) {
        searchResults.items[j].insertText(jobMapping[i].person, Word.InsertLocation.replace);

        await context.sync();
      }
    }
});
```

В предыдущем коде есть внешний и внутренний цикл. Каждый из них содержит `context.sync` . На основе самого первого фрагмента кода в этой статье вы, вероятно, увидите, что внутренний цикл можно просто `context.sync` перемещать после внутреннего цикла. Но это по-прежнему оставляет код с (два из них на `context.sync` самом деле) во внешнем цикле. В следующем коде показано, как можно удалить `context.sync` из циклов. Ниже мы обсудим код.

```javascript
Word.run(async (context) => {

    const allSearchResults = [];
    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');
      let correlatedSearchResult = {
        rangesMatchingJob: searchResults,
        personAssignedToJob: jobMapping[i].person
      }
      allSearchResults.push(correlatedSearchResult);
    }

    await context.sync()

    for (let i = 0; i < allSearchResults.length; i++) {
      let correlatedObject = allSearchResults[i];

      for (let j = 0; j < correlatedObject.rangesMatchingJob.items.length; j++) {
        let targetRange = correlatedObject.rangesMatchingJob.items[j];
        let name = correlatedObject.personAssignedToJob;
        targetRange.insertText(name, Word.InsertLocation.replace);
      }
    }

    await context.sync();
});
```

Обратите внимание, что код использует шаблон раздельного цикла.

- Внешний цикл из предыдущего примера был разделен на два. (Второй цикл имеет внутренний цикл, который ожидается, так как код итерирует над набором заданий (или держателей) и в этом наборе он итерирует над диапазонами совпадений.)
- Существует после `context.sync` каждого крупного цикла, но не внутри `context.sync` цикла.
- Второй основной цикл итерирует массив, созданный в первом цикле.

Но массив, созданный в  первом цикле, не содержит только объект Office, как это сделал первый цикл в разделе Чтение значений из документа с шаблоном [раздельного цикла](#read-values-from-the-document-with-the-split-loop-pattern). Это происходит из-за того, что некоторые сведения, необходимые для обработки объектов диапазона Word, не находятся в самих объектах Range, а приходят из `jobMapping` массива.

Таким образом, объекты массива, созданные в первом цикле, — это настраиваемые объекты, которые имеют два свойства. Первый — это массив диапазонов Word, которые соответствуют определенному названию задания (то есть строке задатки), а второй — строке, которая предоставляет имя человека, назначенного на задание. Это упрощает написание окончательного цикла и упрощает чтение, так как вся информация, необходимая для обработки данного диапазона, содержится в том же настраиваемом объекте, который содержит диапазон. Имя, которое должно заменить _**correlatedObject**.rangesMatchingJob.items[j],_ является другим свойством того же объекта: _**correlatedObject**.personAssignedToJob_.

Этот вариант шаблона раздельного цикла мы называем **шаблоном коррелирующих объектов.** Общая идея состоит в том, что первый цикл создает массив настраиваемого объекта. Каждый объект имеет свойство, значение которого является одним из элементов в объекте Office коллекции (или массиве таких элементов). Настраиваемый объект имеет другие свойства, каждое из которых предоставляет сведения, необходимые для обработки Office объектов в финальном цикле. См. в разделе [Другие примеры](#other-examples-of-these-patterns) этих шаблонов для ссылки на пример, в котором настраиваемый объект соотносится более чем с двумя свойствами.

Еще один нюанс: иногда для создания массива настраиваемого коррелирующих объектов требуется несколько циклов. Это может произойти, если необходимо прочитать свойство каждого члена одного объекта Office только для сбора сведений, которые будут использоваться для обработки другого объекта коллекции. (Например, код должен читать заголовки всех столбцов в таблице Excel, так как надстройка будет применять формат номеров к ячейкам некоторых столбцов на основе заголовка этого столбца.) Но вы всегда можете сохранить `context.sync` s между циклами, а не в цикле. В примере [см. раздел](#other-examples-of-these-patterns) Другие примеры этих шаблонов.

## <a name="other-examples-of-these-patterns"></a>Другие примеры этих шаблонов

- В очень простом примере для Excel, использующих циклы, см. принятый ответ на этот вопрос о переполнении стека: возможно ли стоять в очереди несколько `Array.forEach` [context.load перед context.sync?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)
- Простой пример для Word, которое использует циклы и не использует синтаксис, см. в принятом ответе на этот вопрос Переполнение стека: Итерирование всех абзацев с управлением контентом с Office `Array.forEach` `async` / `await` [API JavaScript](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).
- Пример word, который написан в TypeScript, см. в примере Word [Add-in Angular2 Style Checker](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), особенно файл [word.document.service.ts](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts). Он имеет смесь `for` и `Array.forEach` циклы.
- Для продвинутого примера Word [импортировать этот gist](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) в средство [Script Lab.](../overview/explore-with-script-lab.md) Для контекста с помощью gist см. принятый ответ на вопрос Stack Overflow Document, который не синхронизируется [после замены текста.](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text) В этом примере создается настраиваемый тип объекта, который имеет три свойства. Для построения массива коррелирующих объектов используется в общей сложности три цикла и еще два цикла для окончательной обработки. Существует сочетание циклов `for` `Array.forEach` и циклов.
- Хотя не является строго примером шаблонов раздельного цикла или соотносимых объектов, существует расширенный пример Excel, который показывает, как преобразовать набор значений ячейки в другие валюты с помощью одного . `context.sync` Чтобы попробовать его, откройте [Script Lab и](../overview/explore-with-script-lab.md) перейдите к примеру **конвертера** валюты.

## <a name="when-should-you-not-use-the-patterns-in-this-article"></a>Когда не *следует использовать* шаблоны в этой статье?

Excel не может прочитать более 5 МБ данных в заданный вызов `context.sync` . Если это ограничение превышено, будет выброшена ошибка. (Дополнительные сведения см. в разделе Excel [](resource-limits-and-performance-optimization.md#excel-add-ins) надстройки" ограничений ресурсов и оптимизации производительности для Office надстройки.) Очень редко к этому ограничению подходят, но если есть вероятность, что это произойдет с вашей  надстройкой, то код не должен загружать все данные в один цикл и следовать циклу с `context.sync` помощью . Но все равно следует избегать каждой итерации цикла над `context.sync` объектом коллекции. Вместо этого определите подсети элементов в коллекции и петлю по каждому подмножество в свою очередь, с между `context.sync` циклами. Вы можете структурировать это с помощью внешнего цикла, который итерирует над подсетями и содержит в каждой из этих `context.sync` внешних итераций.
