---
title: Избегайте использования метода context.sync в циклах
description: Узнайте, как использовать цикл разбиения и сопоставленные шаблоны объектов, чтобы избежать вызова context.sync в цикле.
ms.date: 07/18/2022
ms.localizationpriority: medium
ms.openlocfilehash: d8327ad0b6c91a23452cf3efc791876f30408ceb
ms.sourcegitcommit: df7964b6509ee6a807d754fbe895d160bc52c2d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/20/2022
ms.locfileid: "66889214"
---
# <a name="avoid-using-the-contextsync-method-in-loops"></a>Избегайте использования метода context.sync в циклах

> [!NOTE]
> В этой статье предполагается, что вы выходите за рамки начального этапа работы по крайней мере с одним из четырех API JavaScript&mdash;office для Excel, Word, OneNote и Visio&mdash;, которые используют пакетную систему для взаимодействия с документом Office. В частности, следует знать, что `context.sync` делает вызов, и знать, что такое объект коллекции. Если вы не на этом этапе, начните с понимания [API JavaScript для Office](../develop/understanding-the-javascript-api-for-office.md) и документации, связанной с разделом "Конкретное приложение" в этой статье.

В некоторых сценариях программирования в надстройки Office, использующих одну из моделей API для конкретного приложения (для Excel, Word, OneNote и Visio), код должен считывать, записывать или обрабатывать некоторые свойства из каждого элемента объекта коллекции. Например, надстройка Excel, которая должна получить значения каждой ячейки в определенном столбце таблицы или надстройку Word, которая должна выделять каждый экземпляр строки в документе. Необходимо выполнить итерацию `items` по элементам в свойстве объекта коллекции, `context.sync` но из соображений производительности следует избегать вызовов при каждой итерации цикла. Каждый звонок — `context.sync` это круговой путь из надстройки в документ Office. Повторяющиеся круговые поездки влияют на производительность, особенно если надстройка работает в Office в Интернете так как круговые пути выполняются через Интернет.

> [!NOTE]
> Все примеры в этой `for` статье используют циклы, но описанные рекомендации применимы к любому оператору цикла, который может выполнять итерацию по массиву, включая следующие:
>
> - `for`
> - `for of`
> - `while`
> - `do while`
>
> Они также применяются к любому методу массива, в который передается и применяется функция к элементам массива, включая следующие:
>
> - `Array.every`
> - `Array.forEach`
> - `Array.filter`
> - `Array.find`
> - `Array.findIndex`
> - `Array.map`
> - `Array.reduce`
> - `Array.reduceRight`
> - `Array.some`

## <a name="writing-to-the-document"></a>Запись в документ

В простейшем случае запись выполняется только в члены объекта коллекции, а не в их свойства. Например, следующий код выделяет желтым цветом каждый экземпляр "the" в документе Word.

> [!NOTE]
> Как правило, `context.sync` рекомендуется добавить окончательный символ перед закрывающего символа "}" `run` метода приложения ( `Excel.run`например, , `Word.run`и т. д.). Это связано с тем `run` `context.sync` , что метод выполняет скрытый вызов в качестве последнего действия, если есть команды в очереди, которые еще не синхронизированы. Тот факт, что этот вызов скрыт, может привести к путанице, поэтому обычно рекомендуется добавить явный вызов `context.sync`. Тем не менее `context.sync`, учитывая, что эта статья посвящена минимизации вызовов, добавление совершенно ненужного окончательного вызова на самом деле сложнее `context.sync`. Поэтому в этой статье мы оставьте это, если в конце несинхронизированных команд `run`нет.

```javascript
await Word.run(async function (context) {
  let startTime, endTime;
  const docBody = context.document.body;

  // search() returns an array of Ranges.
  const searchResults = docBody.search('the', { matchWholeWord: true });
  searchResults.load('font');
  await context.sync();

  // Record the system time.
  startTime = performance.now();

  for (let i = 0; i < searchResults.items.length; i++) {
    searchResults.items[i].font.highlightColor = '#FFFF00';

    await context.sync(); // SYNCHRONIZE IN EACH ITERATION
  }
  
  // await context.sync(); // SYNCHRONIZE AFTER THE LOOP

  // Record the system time again then calculate how long the operation took.
  endTime = performance.now();
  console.log("The operation took: " + (endTime - startTime) + " milliseconds.");
})
```

Предыдущий код занимал 1 полную секунду для выполнения в документе с 200 экземплярами "the" в Word в Windows. Но если `await context.sync();` строка внутри цикла закомментироваться и та же строка сразу после раскомментирования цикла, операция занимает только 1/10 секунды. В Word в Интернете (с Edge в качестве браузера) синхронизация внутри цикла занимает 3 полных секунды и только 6/10 секунд с синхронизацией после цикла примерно в пять раз быстрее. В документе с 2000 экземплярами "the" (в Word в Интернете) потребовалось 80 секунд с синхронизацией внутри цикла и только 4 секунды с синхронизацией после цикла, примерно в 20 раз быстрее.

> [!NOTE]
> Стоит задать вопрос, будет ли синхронизированная версия внутри цикла выполняться быстрее, если синхронизация выполняется параллельно, `await` `context.sync()`что можно сделать, просто удалив ключевое слово из передней части . Это приведет к тому, что среда выполнения запустит синхронизацию, а затем сразу же запустит следующую итерацию цикла, не дожидаясь завершения синхронизации. Однако это не так хорошо, `context.sync` как перемещение из цикла полностью по этим причинам.
>
> - Так же как команды в пакетном задании синхронизации поставлены в очередь, сами пакетные задания поставлены в очередь в Office, но Office поддерживает не более 50 пакетных заданий в очереди. Другие ошибки триггеров. Таким образом, если цикл содержит более 50 итератов, существует вероятность превышения размера очереди. Чем больше итератов, тем больше вероятность этого.
> - "Параллельно" не означает одновременно. Выполнение нескольких операций синхронизации по-прежнему займет больше времени, чем выполнение одной из них.
> - Параллельные операции не обязательно завершались в том же порядке, в котором они были запущены. В предыдущем примере не имеет значения, в каком порядке выделяется слово "the", но в некоторых случаях важно, чтобы элементы в коллекции обрабатывались по порядку.

## <a name="read-values-from-the-document-with-the-split-loop-pattern"></a>Чтение значений из документа с помощью шаблона разделенного цикла

Предотвращение `context.sync`ошибок внутри цикла становится более сложной задачей, когда  код должен считывать свойство элементов коллекции при обработке каждого из них. Предположим, что коду необходимо выполнить итерацию всех элементов управления содержимым в документе Word и занося в журнал текст первого абзаца, связанного с каждым элементом управления. При программировании может возникнуть циклический перебор элементов управления, `text` загрузка свойства каждого (первого) абзаца, `context.sync` вызов для заполнения прокси-объекта абзаца текстом из документа и его запись в журнал. Ниже приведен пример.

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load('items');
    await context.sync();

    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      await context.sync();
      console.log(paragraph.text);
    }
});
```

В этом сценарии, чтобы `context.sync` избежать циклов, следует использовать шаблон, который мы называем **шаблоном разбиения цикла** . Давайте рассмотрим конкретный пример шаблона, прежде чем получить его формальное описание. Вот как можно применить шаблон цикла разбиения к предыдущему фрагменту кода. Обратите внимание на указанные ниже аспекты этого кода.

- Теперь между ними есть `context.sync` два цикла, поэтому внутри них нет `context.sync` ни один из них.
- Первый цикл `text` выполняет итерацию по элементам в объекте коллекции и загружает свойство так же, как и исходный цикл, `context.sync` `text` `paragraph` но первый цикл не может занося текст абзаца в журнал, так как он больше не содержит свойство прокси-объекта. Вместо этого объект добавляется `paragraph` в массив.
- Второй цикл выполняет итерацию по массиву, созданному первым циклом, `text` и регистрирует каждый `paragraph` элемент. Это возможно, так как `context.sync` элемент, полученный между двумя циклами, заполнит все `text` свойства.

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load("items");
    await context.sync();

    const firstParagraphsOfCCs = [];
    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      firstParagraphsOfCCs.push(paragraph);
    }

    await context.sync();

    for (let i = 0; i < firstParagraphsOfCCs.length; i++) {
      console.log(firstParagraphsOfCCs[i].text);
    }
});
```

В предыдущем примере предлагается следующую процедуру для включения цикла, содержащего цикл `context.sync` разбиения.

1. Замените цикл двумя циклами.
2. Создайте первый цикл для итерации по коллекции и добавьте каждый элемент в массив, а также загрузите любое свойство элемента, которое код должен прочитать.
3. После первого цикла вызовите `context.sync` , чтобы заполнить прокси-объекты любыми загруженными свойствами.
4. Выполните `context.sync` второй цикл, чтобы выполнить итерацию по массиву, созданному в первом цикле, и прочитать загруженные свойства.

## <a name="process-objects-in-the-document-with-the-correlated-objects-pattern"></a>Обработка объектов в документе с помощью шаблона коррелированных объектов

Рассмотрим более сложный сценарий, в котором для обработки элементов в коллекции требуются данные, которых нет в самих элементах. Сценарий предполагает надстройку Word, которая работает с документами, созданными на основе шаблона, с некоторым стандартным текстом. В тексте есть один или несколько экземпляров следующих строк заполнителей: "{Координатор}", "{Deputy}" и "{Manager}". Надстройка заменяет каждый заполнитель именем определенного человека. Пользовательский интерфейс надстройки не важен для этой статьи. Например, в ней может быть область задач с тремя текстовыми полями, каждая из которых помечена одним из заполнителей. Пользователь вводит имя в каждое текстовое поле, а затем нажимает кнопку **"Заменить** ". Обработчик кнопки создает массив, который сопоставляет имена с заполнителями, а затем заменяет каждый заполнитель назначенным именем.

Вам не нужно создавать надстройку с этим пользовательским интерфейсом, чтобы поэкспериментировать с кодом. Вы можете использовать Script Lab [для](../overview/explore-with-script-lab.md) создания прототипа важного кода. Используйте следующую инструкцию присваивания для создания массива сопоставления.

```javascript
const jobMapping = [
        { job: "{Coordinator}", person: "Sally" },
        { job: "{Deputy}", person: "Bob" },
        { job: "{Manager}", person: "Kim" }
    ];
```

В следующем коде показано, как заменить каждый заполнитель назначенным именем при использовании внутри `context.sync` циклов.

```javascript
Word.run(async (context) => {

    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');

      await context.sync(); 

      for (let j = 0; j < searchResults.items.length; j++) {
        searchResults.items[j].insertText(jobMapping[i].person, Word.InsertLocation.replace);

        await context.sync();
      }
    }
});
```

В приведенном выше коде имеется внешний и внутренний цикл. Каждый из них содержит объект `context.sync`. На основе самого первого фрагмента кода в этой статье вы, вероятно, увидите, `context.sync` что внутренний цикл можно просто переместить после внутреннего цикла. Но это по-прежнему оставляет код `context.sync` с (два из них фактически) во внешнем цикле. В следующем коде показано, как удалить `context.sync` из циклов. Мы рассмотрим приведенный ниже код.

```javascript
Word.run(async (context) => {

    const allSearchResults = [];
    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');
      let correlatedSearchResult = {
        rangesMatchingJob: searchResults,
        personAssignedToJob: jobMapping[i].person
      }
      allSearchResults.push(correlatedSearchResult);
    }

    await context.sync()

    for (let i = 0; i < allSearchResults.length; i++) {
      let correlatedObject = allSearchResults[i];

      for (let j = 0; j < correlatedObject.rangesMatchingJob.items.length; j++) {
        let targetRange = correlatedObject.rangesMatchingJob.items[j];
        let name = correlatedObject.personAssignedToJob;
        targetRange.insertText(name, Word.InsertLocation.replace);
      }
    }

    await context.sync();
});
```

Обратите внимание, что в коде используется шаблон цикла разбиения.

- Внешний цикл из предыдущего примера был разделен на два. (Второй цикл имеет внутренний цикл, который ожидается, так как код выполняет итерации по набору заданий (или заполнителей) и в этом наборе он выполняет итерации по соответствующим диапазонам.)
- Каждый основной `context.sync` цикл имеется после каждого цикла, но не `context.sync` внутри цикла.
- Второй основной цикл выполняет итерацию по массиву, созданному в первом цикле.

Однако массив, созданный в первом цикле, не содержит только объект Office, как это было в первом цикле в разделе "Чтение значений из документа с помощью шаблона [разбиения цикла"](#read-values-from-the-document-with-the-split-loop-pattern). Это связано с тем, что некоторые сведения, необходимые для обработки объектов Диапазона Word, не содержатся в самих объектах Range, а поступают из массива `jobMapping` .

Таким образом, объекты в массиве, созданном в первом цикле, являются пользовательскими объектами, которые имеют два свойства. Первый — это массив диапазонов Word, которые соответствуют определенному названию задания (т. е. строке заполнителя), а второй — строке, которая предоставляет имя человека, назначенного заданию. Это упрощает написание и чтение окончательного цикла, так как вся информация, необходимая для обработки заданного диапазона, содержится в том же пользовательском объекте, который содержит диапазон. Имя, которое должно заменить _correlatedObject.rangesMatchingJob.items[j]_, является другим свойством того же объекта: _**correlatedObject.personAssignedToJob**_.

Мы называем этот вариант шаблона цикла разбиения **шаблоном коррелированных объектов** . Общая идея заключается в том, что первый цикл создает массив пользовательских объектов. Каждый объект имеет свойство, значение которого является одним из элементов в объекте коллекции Office (или массиве таких элементов). Пользовательский объект имеет другие свойства, каждое из которых предоставляет сведения, необходимые для обработки объектов Office в последнем цикле. См. раздел ["Другие примеры этих](#other-examples-of-these-patterns) шаблонов" для ссылки на пример, в котором настраиваемый объект корреляции имеет более двух свойств.

Еще одно предупреждение: иногда для создания массива настраиваемых коррелирующих объектов требуется несколько циклов. Это может произойти, если необходимо прочитать свойство каждого члена одного объекта коллекции Office, чтобы собрать сведения, которые будут использоваться для обработки другого объекта коллекции. (Например, код должен считывать заголовки всех столбцов в таблице Excel, так как надстройка будет применять числовое форматирование к ячейкам некоторых столбцов на основе заголовка этого столбца.) Но вы всегда можете хранить их `context.sync`между циклами, а не в цикле. Пример см. в разделе ["](#other-examples-of-these-patterns) Другие примеры этих шаблонов".

## <a name="other-examples-of-these-patterns"></a>Другие примеры этих шаблонов

- Очень простой пример для Excel `Array.forEach` , использующего циклы, см. в принятом ответе на этот вопрос Stack Overflow: Можно ли в очереди несколько [context.load перед context.sync?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)
- Простой пример для Word `Array.forEach``await` `async`/, использующего циклы и не использующего синтаксис, см. в принятом ответе на этот вопрос Stack Overflow: итерация по всем абзацам с элементами управления содержимым с помощью [API JavaScript для Office](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).
- Пример для Word, написанный на TypeScript, см. в примере средства проверки стиля [надстройки Word Angular2](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), особенно в [файле word.document.service.ts](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts). Он имеет сочетание циклов `for` `Array.forEach` и циклов.
- В расширенном примере Word [импортируйте этот элемент gist](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) в Script Lab[.](../overview/explore-with-script-lab.md) Контекст при использовании gist см. в принятом ответе на вопрос Stack Overflow Document, который не синхронизируется [после замены текста](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text). В этом примере создается настраиваемый тип коррелирующих объектов с тремя свойствами. Он использует в общей сложности три цикла для создания массива коррелированных объектов и еще два цикла для окончательной обработки. Существует сочетание циклов `for` `Array.forEach` и циклов.
- Несмотря на то, что не является строго примером циклов разбиения или связанных шаблонов объектов, существует расширенный пример Excel `context.sync`, в котором показано, как преобразовать набор значений ячеек в другие валюты только с одной . Чтобы попробовать его, откройте средство Script Lab [и](../overview/explore-with-script-lab.md) перейдите к примеру **конвертера валют**.

## <a name="when-should-you-not-use-the-patterns-in-this-article"></a>Когда не *следует использовать* шаблоны, указанные в этой статье?

Excel не может прочитать более 5 МБ данных в заданный вызов `context.sync`. Если это ограничение превышено, возникает ошибка. (Дополнительные сведения см. в разделе "Надстройки Excel" ограничений ресурсов и оптимизации производительности для надстроек [Office](resource-limits-and-performance-optimization.md#excel-add-ins).) Это ограничение встречается очень редко, но если есть вероятность, что это произойдет с надстройке,  `context.sync`код не должен загружать все данные в одном цикле и следовать циклу с помощью . Но по-прежнему следует избегать каждой `context.sync` итерации цикла над объектом коллекции. Вместо этого определите подмножества элементов в коллекции и зациклив каждый подмножество по очереди с `context.sync` переключение между циклами. Это можно структурировать с помощью внешнего цикла, `context.sync` который выполняет итерацию по подмножествам и содержит все эти внешние итерации.
