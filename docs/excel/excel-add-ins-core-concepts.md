---
title: Основные концепции программирования с помощью API JavaScript для Excel
description: Создание надстроек для Excel с помощью API JavaScript для Excel.
ms.date: 11/29/2018
ms.openlocfilehash: b32efc539b983a0fc0d1e8696869cedbb0a14095
ms.sourcegitcommit: 60fd8a3ac4a6d66cb9e075ce7e0cde3c888a5fe9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/28/2018
ms.locfileid: "27457903"
---
# <a name="fundamental-programming-concepts-with-the-excel-javascript-api"></a>Основные концепции программирования с помощью API JavaScript для Excel
 
В этой статье описано, как создавать надстройки для Excel 2016 или более поздней версии с помощью [API JavaScript для Excel](https://docs.microsoft.com/office/dev/add-ins/reference/overview/excel-add-ins-reference-overview). В статье изложены основные принципы, которые являются фундаментальными при использовании этого API, а также имеются рекомендации по выполнению определенных задач, например чтению данных из большого диапазона или записи данных в него, изменения всех ячеек в диапазоне и много другого.

## <a name="asynchronous-nature-of-excel-apis"></a>Асинхронный характер API Excel

Веб-надстройки Excel работают в контейнере браузера, внедренном в приложение Office на платформах для настольных ПК, например Office для Windows, и работающем в iFrame HTML в Office Online. Вам не удастся заставить API Office.js синхронно взаимодействовать с ведущим приложением Excel на всех поддерживаемых платформах из-за соображений производительности. Таким образом, вызов API **sync()** в Office.js возвращает [обещание](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise), которое разрешается, когда приложение Excel выполняет запрошенные действия чтения или записи. Кроме того, вы можете поместить в очередь несколько действий, например действия настройки свойств или вызова методов, а затем запустить их в виде пакета команд в одном вызове метода **sync()**, а не отправлять отдельные запросы для каждого действия. В разделах ниже описано, как сделать это, используя API **Excel.run()** и **sync()**.
 
## <a name="excelrun"></a>Excel.run
 
**Excel.run** выполняет функцию, в которой вы указываете действия, которые необходимо совершить над объектной моделью Excel. **Excel.run** автоматически создает контекст запроса, который вы можете использовать для взаимодействия с объектами Excel. Когда **Excel.run** завершает работу, обещание разрешается, и все объекты, которые были выделены в среде выполнения, будут автоматически разблокированы.
 
В примере ниже показано, как использовать **Excel.run**. Оператор catch перехватывает и записывает ошибки, возникающие в **Excel.run**, в журнал.
 
```js
Excel.run(function (context) {
  // You can use the Excel JavaScript API here in the batch function
  // to execute actions on the Excel object model.
  console.log('Your code goes here.');
}).catch(function (error) {
  console.log('error: ' + error);
  if (error instanceof OfficeExtension.Error) {
    console.log('Debug info: ' + JSON.stringify(error.debugInfo));
  }
});
```

### <a name="run-options"></a>Параметры выполнения

В **Excel.run** есть перегрузка, получающая объект [RunOptions](/javascript/api/excel/excel.runoptions). Он содержит набор свойств, влияющих на поведение платформы при выполнении функции. Ниже перечислены поддерживаемые в настоящее время свойства.

 - `delayForCellEdit`: определяет, откладывает ли Excel пакетный запрос до выхода пользователя из режима правки ячейки. Если присвоено значение **true**, пакетный запрос откладывается и запускается, когда пользователь выходит из режима правки ячейки. Если присвоено значение **false**, происходит автоматический сбой пакетного запроса, если пользователь находится в режиме правки ячейки (приводит к ошибке обращения к пользователю). Поведение по умолчанию при отсутствии заданного свойства `delayForCellEdit` аналогично поведению при значении **false**.

```js
Excel.run({ delayForCellEdit: true }, function (context) { ... })
```

## <a name="request-context"></a>Контекст запроса
 
Excel и ваша надстройка запускаются как два отдельных процесса. Так как они используют разные среды выполнения, надстройкам Excel требуется объект **RequestContext**, чтобы можно было подключать надстройку к объектам в Excel, например к листам, диапазонам, диаграммам и таблицам.
 
## <a name="proxy-objects"></a>Прокси-объекты
 
Объекты JavaScript в Excel, которые вы объявляете и используете в надстройке, представляют собой прокси-объекты. Все методы, которые вы вызываете, либо свойства, которые вы настраиваете либо загружаете, в прокси-объектах просто добавляются в очередь команд, ожидающих выполнения. Когда вы вызываете метод **sync()** в контексте запроса (например, `context.sync()`), команды, помещенные в очередь, передаются в Excel и выполняются. По существу, API JavaScript для Excel ориентирован на работу с пакетами. Вы можете поместить в очередь любое количество изменений в контексте запроса, а затем вызвать метод **sync()**, чтобы запустить пакет команд, помещенных в очередь.
 
Например, во фрагменте кода ниже показано, как объявить локальный объект JavaScript **selectedRange** для ссылки на выделенный диапазон в документе Excel, а затем задать ряд свойств для этого объекта. Объект **selectedRange** представляет собой прокси-объект, поэтому свойства, заданные в этом объекте, и методы, вызванные в этом объекте, не будут отображены в документе Excel, пока надстройка не вызовет метод **context.sync()**.
 
```js
const selectedRange = context.workbook.getSelectedRange();
selectedRange.format.fill.color = "#4472C4";
selectedRange.format.font.color = "white";
selectedRange.format.autofitColumns();
```
 
### <a name="sync"></a>sync()
 
При вызове метода **sync()** в контексте запроса будет синхронизировано состояние прокси-объектов и объектов в документе Excel. Метод **sync()** запускает любые команды, помещенные в очередь в контексте запроса, и получает значения для любых свойств, которые следует загрузить, в прокси-объектах. Метод **sync()** выполняется асинхронно и возвращает [обещание](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise), которое разрешается по завершении работы метода **sync()**.
 
В примере ниже показана пакетная функция, которая определяет локальный прокси-объект JavaScript (**selectedRange**), загружает свойство этого объекта, а затем использует шаблон JavaScript Promises для вызова метода **context.sync()** и, соответственно, синхронизации состояния прокси-объектов и объектов в документе Excel.
 
```js
Excel.run(function (context) {
  const selectedRange = context.workbook.getSelectedRange();
  selectedRange.load('address');
  return context.sync()
    .then(function () {
      console.log('The selected range is: ' + selectedRange.address);
  });
}).catch(function (error) {
  console.log('error: ' + error);
  if (error instanceof OfficeExtension.Error) {
    console.log('Debug info: ' + JSON.stringify(error.debugInfo));
  }
});
```
 
В предыдущем примере при вызове метода **context.sync()** задается объект **selectedRange** и загружается его свойство **address**.
 
Так как **sync()**  — асинхронная операция, возвращающая обещание, вам всегда следует **возвращать** обещание (в JavaScript). Это гарантирует, что операция **sync()** будет завершена до того как продолжится выполнение скрипта. Дополнительные сведения об оптимизации производительности с помощью метода **sync()** см. в статье [Оптимизация производительности API JavaScript для Excel](https://docs.microsoft.com/office/dev/add-ins/excel/performance).
 
### <a name="load"></a>load()
 
Чтобы можно было считывать свойства прокси-объекта, вам необходимо явно загрузить их и заполнить прокси-объект данными из документа Excel, а затем вызвать метод **context.sync()**. Например, вы создали прокси-объект для ссылки на выделенный диапазон, а затем вам потребовалось считать свойство **address** выделенного диапазона. Прежде чем вы сможете считать свойство **address**, вам потребуется загрузить его. Чтобы запросить загрузку свойств прокси-объекта, вызовите метод **load()** в объекте и укажите свойства, которые необходимо загрузить. 

> [!NOTE]
> Если вы вызываете методы или задаете свойства только в прокси-объекте, вам не нужно вызывать объект **load()**. Метод **load()** требуется только тогда, когда вам необходимо считать свойства в прокси-объекте.
 
Аналогично запросам для задания свойств или вызова методов в прокси-объектах, запросы на загрузку свойств в прокси-объектах добавляются в очередь команд, ожидающих выполнения, в контексте запроса, который будет запущен, когда вы в следующий раз вызовете метод **sync()**. В очередь можно поставить сколько угодно вызовов **load()** в контексте запроса.
 
В примере ниже загружаются только определенные свойства диапазона.
 
```js
Excel.run(function (context) {
  const sheetName = 'Sheet1';
  const rangeAddress = 'A1:B2';
  const myRange = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
 
  myRange.load(['address', 'format/*', 'format/fill', 'entireRow' ]);
 
  return context.sync()
    .then(function () {
      console.log (myRange.address);              // ok
      console.log (myRange.format.wrapText);      // ok
      console.log (myRange.format.fill.color);    // ok
      //console.log (myRange.format.font.color);  // not ok as it was not loaded
  });
}).then(function () {
  console.log('done');
}).catch(function (error) {
  console.log('Error: ' + error);
  if (error instanceof OfficeExtension.Error) {
    console.log('Debug info: ' + JSON.stringify(error.debugInfo));
  }
});
```
 
Так как в предыдущем примере в вызове метода **myRange.load()** не указан `format/font`, вам не удастся считать свойство `format.font.color`.

Чтобы оптимизировать производительность, при использовании метода **load()** в объекте вам следует явно указать свойства и связи, которые необходимо загрузить, как описано в статье [Оптимизация производительности API JavaScript для Excel](performance.md). Дополнительные сведения о методе **load()** см. в статье [Дополнительные концепции программирования с помощью API JavaScript для Excel](excel-add-ins-advanced-concepts.md).

## <a name="null-or-blank-property-values"></a>Значения null или пустые значения свойств
 
### <a name="null-input-in-2-d-array"></a>Входное значение null в двумерном массиве
 
В Excel диапазон представлен двумерным массивом, в котором первое измерение — это строки, а второе — столбцы. Чтобы задать значения, формат чисел или формулу только для определенных ячеек в диапазоне, укажите значения, формат чисел или формулу для этих ячеек в двумерном массиве, а для всех остальных ячеек в этом массиве укажите значение `null`.
 
Например, чтобы изменить формат чисел только для одной ячейки в диапазоне и сохранить существующий формат чисел для всех остальных ячеек в диапазоне, укажите новый формат чисел для ячейки, которую необходимо изменить, а для всех остальных ячеек укажите значение `null`. Во фрагменте кода ниже показано, как задать новый формат чисел для четвертой ячейки в диапазоне, при этом формат чисел для первых трех ячеек в диапазоне останется неизменным.
 
```js
range.values = [['Eurasia', '29.96', '0.25', '15-Feb' ]];
range.numberFormat = [[null, null, null, 'm/d/yyyy;@']];
```
 
### <a name="null-input-for-a-property"></a>Входное значение null для свойства
 
`null` не является допустимым входным значением для одного свойства. Например, указанный ниже фрагмент кода не является допустимым, так как свойство **values** диапазона не должно иметь значение `null`.
 
```js
range.values = null;
```
 
Аналогично, указанный ниже фрагмент кода не является допустимым, так как `null` — недопустимое значение для свойства **color**.
 
```js
range.format.fill.color =  null;
```
 
### <a name="null-property-values-in-the-response"></a>Значения свойств null в ответе
 
Если в указанном диапазоне имеются другие значения, свойства форматирования, например `size` и `color` будут содержать значения `null` в ответе. Например, если вы получаете диапазон и загружаете его свойство `format.font.color`:
 
* Если у всех ячеек в диапазоне один и тот же цвет шрифта, свойство `range.format.font.color` указывает этот цвет.
* Если в диапазоне используется несколько цветов шрифтов, свойство `range.format.font.color` имеет значение `null`.
 
### <a name="blank-input-for-a-property"></a>Пустое входное значение для свойства
 
Когда вы указываете пустое значение для свойства (то есть две кавычки подряд без других знаков между `''`), это будет интерпретировано как инструкция по очистке или сбросу свойства. Например:
 
* Если вы укажете пустое значение для свойства `values` диапазона, содержимое диапазона будет очищено.
 
* Если вы укажете пустое значение для свойства `numberFormat`, формат чисел будет "сброшен" до формата `General`.
 
* Если вы укажете пустое значение для свойств `formula` и `formulaLocale`, значения формул будут очищены.
 
### <a name="blank-property-values-in-the-response"></a>Значения пустых свойств в ответе
 
Для операций чтения пустое значение свойства в ответе (то есть две кавычки подряд без других знаков между `''`) указывает, что ячейка не содержит данных или значения. В первом примере ниже первая и последняя ячейки в диапазоне не содержат данных. Во втором примере две первые ячейки в диапазоне не содержат формул.
 
```js
range.values = [['', 'some', 'data', 'in', 'other', 'cells', '']];
```
 
```js
range.formula = [['', '', '=Rand()']];
```
 
## <a name="read-or-write-to-an-unbounded-range"></a>Чтение из неограниченного диапазона и запись в него
 
### <a name="read-an-unbounded-range"></a>Чтение из неограниченного диапазона
 
Адрес неограниченного диапазона представляет собой адрес диапазона, указывающий весь столбец (столбцы) либо всю строку (строки). Например:
 
* Адреса диапазона включают в себя весь столбец (столбцы):<ul><li>`C:C`</li><li>`A:F`</li></ul>
* Адреса диапазона включают в себя всю строку (строки):<ul><li>`2:2`</li><li>`1:4`</li></ul>
 
Когда API отправляет запрос на получение неограниченного диапазона (например, `getRange('C:C')`), ответ будет содержать значения `null` для свойств уровня ячейки, например свойств `values`, `text`, `numberFormat` и `formula`. Другие свойства диапазона, например `address` и `cellCount`, будут содержать допустимые значения для неограниченного диапазона.
 
### <a name="write-to-an-unbounded-range"></a>Запись в неограниченный диапазон
 
Вам не удастся задать свойства уровня ячейки, например `values`, `numberFormat` и `formula`, в неограниченном диапазоне, так как входной запрос слишком велик. Например, приведенный ниже фрагмент кода недопустим, так как он пытается указать свойство `values` для неограниченного диапазона. Если вы попытаетесь задать свойства уровня ячейки для неограниченного диапазона, API возвратит ошибку.
 
```js
const range = context.workbook.worksheets.getActiveWorksheet().getRange('A:B');
range.values = 'Due Date';
```
 
## <a name="read-or-write-to-a-large-range"></a>Чтение из большого диапазона и запись в него
 
Если диапазон содержит большое количество ячеек, значений, форматов чисел или формул, то, возможно, не удастся выполнить операции API над этим диапазоном. API всегда делает все возможное, чтобы выполнить запрошенную операцию над диапазоном (то есть получить или записать указанные данные), но попытка выполнить операцию чтения или записи для большого диапазона может привести к ошибке API из-за чрезмерного потребления ресурсов. Чтобы избежать таких ошибок, мы рекомендуем выполнять отдельные операции чтения или записи для небольших подмножеств большого диапазона, а не пытаться выполнить одну операцию чтения или записи для большого диапазона.
 
## <a name="update-all-cells-in-a-range"></a>Изменение всех ячеек в диапазоне
 
Если необходимо одинаково изменить все ячейки в диапазоне (например, заполнить все ячейки одним и тем же значением или формулой либо задать один и тот же формат чисел), задайте для соответствующего свойства в объекте **range** (одно) необходимое значение.
 
В примере ниже показано, как получить диапазон, содержащий 20 ячеек, а затем задать формат чисел и заполнить все ячейки в диапазоне значением **3/11/2015** (11.03.2015).
 
```js
Excel.run(function (context) {
  const sheetName = 'Sheet1';
  const rangeAddress = 'A1:A20';
  const worksheet = context.workbook.worksheets.getItem(sheetName);
 
  const range = worksheet.getRange(rangeAddress);
  range.numberFormat = 'm/d/yyyy';
  range.values = '3/11/2015';
  range.load('text');
 
  return context.sync()
    .then(function () {
      console.log(range.text);
  });
}).catch(function (error) {
  console.log('Error: ' + error);
  if (error instanceof OfficeExtension.Error) {
    console.log('Debug info: ' + JSON.stringify(error.debugInfo));
  }
});
```
 
##<a name="handle-errors"></a>Обработка ошибок

При возникновении ошибки в интерфейсе API он возвращает объект **error**, содержащий код и сообщение. Подробные сведения об обработке ошибок, включая список ошибок API, см. в статье [Обработка ошибок](excel-add-ins-error-handling.md).
 
## <a name="see-also"></a>См. также
 
* [Начало работы с надстройками Excel](excel-add-ins-get-started-overview.md)
* [Примеры кода надстроек Excel](https://developer.microsoft.com/office/gallery/?filterBy=Samples)
* [Дополнительные концепции программирования с помощью API JavaScript для Excel](excel-add-ins-advanced-concepts.md)
* [Оптимизация производительности API JavaScript для Excel](https://docs.microsoft.com/office/dev/add-ins/excel/performance)
* [Справочник по API JavaScript для Excel](https://docs.microsoft.com/office/dev/add-ins/reference/overview/excel-add-ins-reference-overview)
