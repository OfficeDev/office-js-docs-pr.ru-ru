---
title: Создание пользовательских контекстуальных вкладок Office дополнительных надстройок
description: Узнайте, как добавить пользовательские контекстуальные вкладки в Office add-in.
ms.date: 05/12/2021
localization_priority: Normal
ms.openlocfilehash: d03ac2c01c03353f3e2d1b54ba20616d7b42d93f
ms.sourcegitcommit: 693d364616b42eea66977eef47530adabc51a40f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2021
ms.locfileid: "52555208"
---
# <a name="create-custom-contextual-tabs-in-office-add-ins"></a>Создание пользовательских контекстуальных вкладок Office дополнительных надстройок

Контекстная вкладка представляет 1000 скрытых элементов управления вкладками в ленте Office, которая отображается в строке вкладок при произном событии в Office документа. Например, **вкладка «Дизайн** таблицы», которая отображается на Excel лентой при выборе таблицы. Вы можете включить пользовательские контекстуальные вкладки в Office Add-in и указать, когда они видны или скрыты, создавая обработчики событий, которые меняют видимость. (Однако пользовательские контекстуальные вкладки не реагируют на изменения фокусировки.)

> [!NOTE]
> В этой статье предполагается, что вы уже ознакомились с приведенной ниже документацией. Просмотрите ее, если вы работали с командами надстроек (настраиваемыми элементами меню и кнопками ленты) некоторое время назад.
>
> - [Основные концепции команд надстроек](add-in-commands.md)

> [!IMPORTANT]
> Пользовательские контекстуальные вкладки в настоящее время поддерживаются только Excel и только на этих платформах и сборках:
>
> - Excel на Windows (Microsoft 365 подписка): Версия 2102 (Build 13801.20294) или позже.
> - Excel в Интернете

> [!NOTE]
> Пользовательские контекстуальные вкладки работают только на платформах, хтякуя следующих наборов требований. Для получения дополнительной информации о наборах требований и о том, как с ними [работать, Office приложений и требований API.](../develop/specify-office-hosts-and-api-requirements.md)
>
> - [РиббонАпи 1.2](../reference/requirement-sets/ribbon-api-requirement-sets.md)
> - [SharedRuntime 1.1](../reference/requirement-sets/shared-runtime-requirement-sets.md)
>
> Вы можете использовать проверки времени выполнения в коде, чтобы проверить, поддерживает ли комбинация хоста и платформы пользователя эти наборы требований, [описанные в приложениях Office и API.](../develop/specify-office-hosts-and-api-requirements.md#use-runtime-checks-in-your-javascript-code) (Техника указания наборов требований в манифесте, которая также описана в этой статье, в настоящее время не работает для RibbonApi 1.2.) Кроме того, можно реализовать [альтернативный пользовательский интерфейс, когда пользовательские контекстуальные вкладки не поддерживаются.](#implement-an-alternate-ui-experience-when-custom-contextual-tabs-are-not-supported)

## <a name="behavior-of-custom-contextual-tabs"></a>Поведение пользовательских контекстуальных вкладок

Пользовательский интерфейс для пользовательских контекстуальных вкладок следует шаблону встроенных Office контекстуальных вкладок. Ниже приведены основные принципы для размещения пользовательских контекстуальных вкладок:

- Когда видна пользовательская контекстуальная вкладка, она отображается на правом конце ленты.
- Если одновременно видны одна или несколько встроенных контекстуальных вкладок и одна или несколько пользовательских контекстуальных вкладок из надстройок, пользовательские контекстуальные вкладки всегда справа от всех встроенных контекстуальных вкладок.
- Если надстройка имеет несколько контекстуальных вкладок и есть контексты, в которых видно несколько, они отображаются в порядке, в котором они определены в надстройке. (Направление в том же направлении, что и Office язык; то есть слева направо на языках слева направо, но справа налево на языках справа налево.) Определите [группы и элементы управления, которые появляются на вкладке, для получения](#define-the-groups-and-controls-that-appear-on-the-tab) подробной информации о том, как вы их определяете.
- Если более одного дополнения имеет контекстуальную вкладку, видимую в определенном контексте, то они отображаются в порядке запуска надстройок.
- Пользовательские *контекстуальные* вкладки, в отличие от пользовательских основных вкладок, не добавляются Office к ленте приложения. Они присутствуют только в Office документах, на которых работает надстройку.

## <a name="major-steps-for-including-a-contextual-tab-in-an-add-in"></a>Основные шаги для включения контекстной вкладки в надстройку

Ниже приведены основные шаги для включения пользовательской контекстуальной вкладки в дополнение:

1. Настройте надстройу для использования общего времени выполнения.
1. Определите вкладку и группы и элементы управления, которые появляются на ней.
1. Зарегистрируйте контекстную вкладку с помощью Office.
1. Укажите обстоятельства, при которых вкладка будет видна.

## <a name="configure-the-add-in-to-use-a-shared-runtime"></a>Настройка надстройок для использования общего времени выполнения

Добавление пользовательских контекстуальных вкладок требует, чтобы надстройка использовалась в общем времени выполнения. Для получения дополнительной [информации см.](../develop/configure-your-add-in-to-use-a-shared-runtime.md)

## <a name="define-the-groups-and-controls-that-appear-on-the-tab"></a>Определите группы и элементы управления, которые отображаются на вкладке

В отличие от пользовательских основных вкладок, которые определяются с XML в манифесте, пользовательские контекстуальные вкладки определяются во время выполнения с каплей JSON. Код анализирует каплю в объект JavaScript, а затем передает объект в [метод Office.ribbon.requestCreateControls.](/javascript/api/office/office.ribbon?view=common-js&preserve-view=true#requestCreateControls-tabDefinition-) Пользовательские контекстуальные вкладки присутствуют только в документах, на которых в настоящее время работает надстройка. Это отличается от пользовательских основных вкладок, которые добавляются в ленту приложения Office, когда надстройка установлена и остается присутствовать при открытом другом документе. Кроме того, `requestCreateControls` метод может быть запущен только один раз в сеансе вашего дополнения. Если он вызван снова, ошибка брошена.

> [!NOTE]
> Структура свойств и подпредложений капли JSON (и ключевых имен) примерно параллельна структуре [элемента CustomTab и его](../reference/manifest/customtab.md) потомкам в манифесте XML.

Мы построим пример контекстуальных вкладок JSON blob шаг за шагом. Полная схема контекстной вкладки JSON находится [dynamic-ribbon.schema.jsна](https://developer.microsoft.com/json-schemas/office-js/dynamic-ribbon.schema.json). Если вы работаете в Visual Studio Code, вы можете использовать этот файл, чтобы IntelliSense и проверить ваш JSON. Для получения дополнительной информации [см Visual Studio Code.](https://code.visualstudio.com/docs/languages/json#_json-schemas-and-settings)


1. Начните с создания строки JSON с двумя свойствами массива, названными `actions` и `tabs` . Массив `actions` является спецификацией всех функций, которые могут быть выполнены с помощью элементов управления контекстуальной вкладкой. Массив `tabs` определяет одну или несколько контекстуальных *вкладок, максимум до 20.*

    ```json
    '{
      "actions": [

      ],
      "tabs": [

      ]
    }'
    ```

1. Этот простой пример контекстуальной вкладки будет иметь только одну кнопку и, таким образом, только одно действие. Добавьте следующее в качестве единственного члена `actions` массива. Об этой разметке, обратите внимание:

    - Свойства `id` `type` и свойства являются обязательными.
    - Значение может быть `type` либо "ExecuteFunction" или "ShowTaskpane".
    - Свойство `functionName` используется только тогда, когда значение `type` `ExecuteFunction` . Это название функции, определенной в FunctionFile. Для получения дополнительной информации о FunctionFile [см. Основные концепции для дополнительных команд.](add-in-commands.md)
    - На более позднем этапе вы сопоставите это действие с кнопкой на контекстуальной вкладке.

    ```json
    {
      "id": "executeWriteData",
      "type": "ExecuteFunction",
      "functionName": "writeData"
    }
   ```

1. Добавьте следующее в качестве единственного члена `tabs` массива. Об этой разметке, обратите внимание:

    - Свойство `id` является обязательным. Используйте краткий, описательный идентификатор, который уникален среди всех контекстуальных вкладок в надстройке.
    - Свойство `label` является обязательным. Это удобный строка, чтобы служить в качестве метки контекстуальной вкладке.
    - Свойство `groups` является обязательным. Он определяет группы элементов управления, которые будут отображаться на вкладке. Он должен иметь по крайней мере *одного члена и не более 20*. (Есть также ограничения на количество элементов управления, которые можно иметь на пользовательской контекстной вкладке, и что также будет ограничивать, сколько групп, которые у вас есть. Дополнительную информацию можно посмотреть на следующий шаг.)

    > [!NOTE]
    > Объект вкладки также может иметь дополнительное `visible` свойство, которое определяет, видна ли вкладка сразу же при запуске надстройки. Поскольку контекстуальные вкладки обычно скрыты до тех пор, пока событие пользователя не запустит видимость (например, пользователь выбирает сущность того или иного типа в документе), `visible` свойство по умолчанию, `false` когда его нет. В более позднем разделе мы покажем, как настроить свойство `true` в ответ на событие.

    ```json
    {
      "id": "CtxTab1",
      "label": "Contoso Data",
      "groups": [

      ]
    }
    ```

1. В простом постоянном примере контекстуальная вкладка имеет только одну группу. Добавьте следующее в качестве единственного члена `groups` массива. Об этой разметке, обратите внимание:

    - Все свойства необходимы.
    - Свойство должно быть уникальным среди всех групп во `id` вкладке. Используйте краткое, описательное удостоверение личности.
    - Это `label` удобный строка, чтобы служить в качестве ярлыка группы.
    - Значение `icon` свойства – это массив объектов, которые определяют значки, которые группа будет иметь на ленте в зависимости от размера ленты и Office окна приложения.
    - Значение `controls` свойства – это массив объектов, которые определяют кнопки и меню в группе. Должен быть хотя бы один.

    > [!IMPORTANT]
    > *Общее количество элементов управления на всей вкладке может быть не более 20.* Например, можно иметь 3 группы по 6 элементов управления и четвертую группу с 2 элементами управления, но вы не можете иметь 4 группы по 6 элементов управления каждая.  

    ```json
    {
        "id": "CustomGroup111",
        "label": "Insertion",
        "icon": [

        ],
        "controls": [

        ]
    }
    ```

1. Каждая группа должна иметь значок не менее двух размеров, 32x32 px и 80x80 px. Дополнительно, вы также можете иметь значки размеров 16x16 px, 20x20 px, 24x24 px, 40x40 px, 48x48 px, и 64x64 px. Office, какой значок использовать в зависимости от размера ленты и Office окна приложения. Добавьте следующие объекты в массив значков. (Если размеры окна и ленты достаточно велики, чтобы по крайней мере один из *элементов* управления в группе не появлялся, то значок группы вообще не отображается. Например, наблюдайте за **группой** стилей на ленте Word при сокращении и расширении окна Word.) Об этой разметке, обратите внимание:

    - Оба свойства необходимы.
    - Единица `size` измерения свойства пикселей. Иконки всегда квадратные, поэтому число и высота, и ширина.
    - Свойство `sourceLocation` указывает полный URL на значок.

    > [!IMPORTANT]
    > Точно так же, как обычно необходимо изменить URL-адреса в манифесте дополнения при переходе от разработки к производству (например, изменение домена с локального хостинга на contoso.com), вы также должны изменить URL-адреса в контекстуальных вкладок JSON.

    ```json
    {
        "size": 32,
        "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/Group32x32.png"
    },
    {
        "size": 80,
        "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/Group80x80.png"
    }
    ```

1. В нашем простом постоянном примере у группы есть только одна кнопка. Добавьте следующий объект в качестве единственного члена `controls` массива. Об этой разметке, обратите внимание:

    - Все свойства, кроме , `enabled` не требуется.
    - `type` определяет тип управления. Значения могут быть "Кнопка", "Меню", или "MobileButton".
    - `id` может быть до 125 символов. 
    - `actionId` должен быть идентификатор действия, определенный в `actions` массиве. (См. шаг 1 этого раздела.)
    - `label` является удобной строкой, которая служит в качестве метки кнопки.
    - `superTip` представляет собой богатую форму наконечника инструмента. Требуются `title` как `description` свойства, так и свойства.
    - `icon` указывает значки для кнопки. Предыдущие замечания о значке группы применимы и здесь.
    - `enabled` (необязательно) определяет, включена ли кнопка при запуске контекстуальной вкладки. По умолчанию, если нет `true` . 

    ```json
    {
        "type": "Button",
        "id": "CtxBt112",
        "actionId": "executeWriteData",
        "enabled": false,
        "label": "Write Data",
        "superTip": {
            "title": "Data Insertion",
            "description": "Use this button to insert data into the document."
        },
        "icon": [
            {
                "size": 32,
                "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/WriteDataButton32x32.png"
            },
            {
                "size": 80,
                "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/WriteDataButton80x80.png"
            }
        ]
    }
    ```
 
Ниже приводится полный пример капли JSON:

```json
`{
  "actions": [
    {
      "id": "executeWriteData",
      "type": "ExecuteFunction",
      "functionName": "writeData"
    }
  ],
  "tabs": [
    {
      "id": "CtxTab1",
      "label": "Contoso Data",
      "groups": [
        {
          "id": "CustomGroup111",
          "label": "Insertion",
          "icon": [
            {
                "size": 32,
                "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/Group32x32.png"
            },
            {
                "size": 80,
                "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/Group80x80.png"
            }
          ],
          "controls": [
            {
                "type": "Button",
                "id": "CtxBt112",
                "actionId": "executeWriteData",
                "enabled": false,
                "label": "Write Data",
                "superTip": {
                    "title": "Data Insertion",
                    "description": "Use this button to insert data into the document."
                },
                "icon": [
                    {
                        "size": 32,
                        "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/WriteDataButton32x32.png"
                    },
                    {
                        "size": 80,
                        "sourceLocation": "https://cdn.contoso.com/addins/datainsertion/Images/WriteDataButton80x80.png"
                    }
                ]
            }
          ]
        }
      ]
    }
  ]
}`
```

## <a name="register-the-contextual-tab-with-office-with-requestcreatecontrols"></a>Зарегистрируйте контекстную вкладку с помощью Office с запросомCreateControls

Контекстная вкладка регистрируется с Office, [позвонив по Office.ribbon.requestCreateControls.](/javascript/api/office/office.ribbon?view=common-js&preserve-view=true#requestCreateControls_tabDefinition_) Обычно это делается либо в функции, назначенной `Office.initialize` методу, либо с `Office.onReady` ним. Для получения дополнительной информации об этих методах и инициализации надстройок см [Office.](../develop/initialize-add-in.md) Однако можно позвонить в метод в любое время после инициализации.

> [!IMPORTANT]
> Метод `requestCreateControls` может быть вызван только один раз в данном сеансе дополнения. Ошибка брошена, если она вызвана снова.

Ниже приведен пример. Обратите внимание, что строка JSON должна быть преобразована в объект JavaScript с `JSON.parse` помощью метода, прежде чем она может быть передана функции JavaScript.

```javascript
Office.onReady(async () => {
    const contextualTabJSON = ` ... `; // Assign the JSON string such as the one at the end of the preceding section.
    const contextualTab = JSON.parse(contextualTabJSON);
    await Office.ribbon.requestCreateControls(contextualTab);
});
```

## <a name="specify-the-contexts-when-the-tab-will-be-visible-with-requestupdate"></a>Укажите контексты, когда вкладка будет видна с запросомUpdate

Как правило, пользовательская контекстуальная вкладка должна отображаться, когда событие, инициированное пользователем, изменяет контекст дополнения. Рассмотрим сценарий, в котором вкладка должна быть видна, когда и только когда активируется диаграмма (на листе Excel рабочей книги по умолчанию).

Начните с назначения обработчиков. Обычно это делается в `Office.onReady` методе, как в следующем примере, который присваивает обработчикам (созданным на более позднем `onActivated` этапе) и событиям всех диаграмм `onDeactivated` в листе.

```javascript
Office.onReady(async () => {
    const contextualTabJSON = ` ... `; // Assign the JSON string.
    const contextualTab = JSON.parse(contextualTabJSON);
    await Office.ribbon.requestCreateControls(contextualTab);

    await Excel.run(context => {
        var charts = context.workbook.worksheets
            .getActiveWorksheet()
            .charts;
        charts.onActivated.add(showDataTab);
        charts.onDeactivated.add(hideDataTab);
        return context.sync();
    });
});
```

Далее определите обработчиков. Ниже приводится простой пример `showDataTab` , но см [Обработка HostRestartNeeded ошибка позже](#handle-the-hostrestartneeded-error) в этой статье для более надежной версии функции. Вот что нужно знать об этом коде:

- Office определяет время обновления состояния ленты. Метод [Office.ribbon.requestUpdate](/javascript/api/office/office.ribbon?view=common-js&preserve-view=true#requestupdate-input-) выстроил в очередь запрос на обновление. Метод разрешит объект, `Promise` как только он выстроился в очередь с запросом, а не когда лента фактически обновляется.
- Параметром метода `requestUpdate` является объект [RibbonUpdaterData,](/javascript/api/office/office.ribbonupdaterdata) который (1) определяет вкладку по своему *идентификатору точно так, как* указано в JSON и (2) определяет видимость вкладки.
- Если у вас есть несколько пользовательских контекстуальных вкладок, которые должны быть видны в том же контексте, вы просто добавить дополнительные объекты вкладок в `tabs` массив.

```javascript
async function showDataTab() {
    await Office.ribbon.requestUpdate({
        tabs: [
            {
                id: "CtxTab1",
                visible: true
            }
        ]});
}
```

Обработчик, чтобы скрыть вкладку почти идентичны, за исключением того, что он `visible` устанавливает свойство обратно `false` .

Библиотека Office JavaScript также предоставляет несколько интерфейсов (типов), чтобы упростить строительство `RibbonUpdateData` объекта. Ниже приводится `showDataTab` функция в TypeScript и он использует эти типы.

```typescript
const showDataTab = async () => {
    const myContextualTab: Office.Tab = {id: "CtxTab1", visible: true};
    const ribbonUpdater: Office.RibbonUpdaterData = { tabs: [ myContextualTab ]};
    await Office.ribbon.requestUpdate(ribbonUpdater);
}
```

### <a name="toggle-tab-visibility-and-the-enabled-status-of-a-button-at-the-same-time"></a>Переключение видимости вкладок и включенного состояния кнопки одновременно

Метод `requestUpdate` также используется для переключения включенного или отключенного статуса пользовательской кнопки на пользовательской контекстуальной вкладке или пользовательской вкладке ядра. Для получения подробной информации об этом [см.](disable-add-in-commands.md) Могут быть сценарии, в которых вы хотите изменить как видимость вкладки, так и состояние кнопки одновременно. Вы можете сделать это с помощью одного звонка `requestUpdate` . Ниже приводится пример, в котором кнопка на вкладке ядра включена в то же время, как контекстуальная вкладка сделана видимой.

```javascript
function myContextChanges() {
    Office.ribbon.requestUpdate({
        tabs: [
            {
                id: "CtxTab1",
                visible: true
            },
            {
                id: "OfficeAppTab1",
                groups: [
                    {
                        id: "CustomGroup111",
                        controls: [
                            {
                                id: "MyButton",
                                enabled: true
                            }
                        ]
                    }
                ]
            ]}
        ]
    });
}
```

В следующем примере кнопка, включенная, находится на той же контекстной вкладке, которая делается видимой.

```javascript
function myContextChanges() {
    Office.ribbon.requestUpdate({
        tabs: [
            {
                id: "CtxTab1",
                visible: true,
                groups: [
                    {
                        id: "CustomGroup111",
                        controls: [
                            {
                                id: "MyButton",
                                enabled: true
                           }
                       ]
                   }
               ]
            }
        ]
    });
}
```

## <a name="localizing-the-json-blob"></a>Локализация капли JSON

Bb JSON, передаваемый, не локализован так `requestCreateControls` же, как локализовка манифеста для пользовательских основных вкладок (которая [описана при локализации управления из манифеста).](../develop/localization.md#control-localization-from-the-manifest) Вместо этого локализация должна происходить во время выполнения с использованием различных капли JSON для каждого места. Мы предлагаем использовать `switch` выписку, которая тестирует [Office.context.displayLanguage.](/javascript/api/office/office.context#displayLanguage) Ниже приведен пример.

```javascript
function GetContextualTabsJsonSupportedLocale () {
    var displayLanguage = Office.context.displayLanguage;

        switch (displayLanguage) {
            case 'en-US':
                return `{
                    "actions": [
                        // actions omitted
                     ],
                    "tabs": [
                        {
                          "id": "CtxTab1",
                          "label": "Contoso Data",
                          "groups": [
                              // groups omitted
                          ]
                        }
                    ]
                }`;

            case 'fr-FR':
                return `{
                    "actions": [
                        // actions omitted 
                    ],
                    "tabs": [
                        {
                          "id": "CtxTab1",
                          "label": "Contoso Données",
                          "groups": [
                              // groups omitted
                          ]
                       }
                    ]
               }`;

            // Other cases omitted
       }
}
```

Затем код вызывает функцию, чтобы получить локализованную каплю, которая `requestCreateControls` передается, как в следующем примере:

```javascript
var contextualTabJSON = GetContextualTabsJsonSupportedLocale();
```

## <a name="best-practices-for-custom-contextual-tabs"></a>Лучшие практики для пользовательских контекстуальных вкладок

### <a name="implement-an-alternate-ui-experience-when-custom-contextual-tabs-are-not-supported"></a>Реализация альтернативного пользовательского интерфейса при поддержке пользовательских контекстуальных вкладок

Некоторые комбинации платформы, Office приложения и Office сборки не `requestCreateControls` поддерживают. Надстройа должна быть разработана таким образом, чтобы предоставить альтернативный опыт пользователям, которые работают надстройок на одной из этих комбинаций. В следующих разделах описаны два способа обеспечения возврата.

#### <a name="use-noncontextual-tabs-or-controls"></a>Использование неконтекстуальных вкладок или элементов управления

Существует явный элемент, [OverriddenByRibbonApi](../reference/manifest/overriddenbyribbonapi.md), который предназначен для создания обратного опыта в дополнение, которое реализует пользовательские контекстуальные вкладки, когда надстройка работает на приложении или платформе, которая не поддерживает пользовательские контекстуальные вкладки. 

Простейшей стратегией использования этого элемента является определение в манифесте одной или нескольких пользовательских основных вкладок (то есть *неконтекстуальных* пользовательских вкладок), которые дублируют настройки ленты пользовательских контекстуальных вкладок в надстройке. Но вы `<OverriddenByRibbonApi>true</OverriddenByRibbonApi>` добавляете в качестве первого элемента ребенка [CustomTab](../reference/manifest/customtab.md). Результатом этого является следующее:

- Если надстройка выполняется на приложении и платформе, ею поддерживают пользовательские контекстуальные вкладки, то пользовательская вкладка ядра не будет отображаться на ленте. Вместо этого пользовательская контекстуальная вкладка будет создана при вызове `requestCreateControls` надстройки метода.
- Если надстройка выполняется на приложении или платформе, *которая не поддерживает,* `requestCreateControls` то пользовательская вкладка ядра появляется на ленте.

Ниже приводится пример этой простой стратегии.

```xml
<OfficeApp ...>
  ...
  <VersionOverrides ...>
    ...
    <Hosts>
      <Host ...>
        ...
        <DesktopFormFactor>
          <ExtensionPoint ...>
            <CustomTab ...>
              <OverriddenByRibbonApi>true</OverriddenByRibbonApi>
              ...
              <Group ...>
                ...
                <Control ... id="MyButton">
                  ...
                  <Action ...>
...
</OfficeApp>
```

Эта простая стратегия использует пользовательскую основную вкладку, которая отражает пользовательскую контекстуальную вкладку с ее детскими группами и управлениями, но вы можете использовать более сложную стратегию. Элемент `<OverriddenByRibbonApi>` также может быть добавлен в качестве (первого) элемента ребенка в элементы [группы и](../reference/manifest/group.md) [управления](../reference/manifest/control.md) (как тип кнопки, [так и](../reference/manifest/control.md#button-control) тип [меню),](../reference/manifest/control.md#menu-dropdown-button-controls)а также элементы `<Item>` меню. Этот факт позволяет распространять группы и элементы управления, которые в противном случае появились бы на контекстной вкладке между различными группами, кнопками и меню в различных пользовательских основных вкладок. Ниже приведен пример. Обратите внимание, что "MyButton" появится на пользовательской вкладке ядра только тогда, когда пользовательские контекстуальные вкладки не поддерживаются. Но родительская группа и пользовательская вкладка ядра будут отображаться независимо от того, поддерживаются ли пользовательские контекстуальные вкладки.

```xml
<OfficeApp ...>
  ...
  <VersionOverrides ...>
    ...
    <Hosts>
      <Host ...>
        ...
        <DesktopFormFactor>
          <ExtensionPoint ...>
            <CustomTab ...>              
              ...
              <Group ...>
                ...
                <Control ... id="MyButton">
                  <OverriddenByRibbonApi>true</OverriddenByRibbonApi>
                  ...
                  <Action ...>
...
</OfficeApp>
```

Дополнительные примеры [см.](../reference/manifest/overriddenbyribbonapi.md)

Когда родительские вкладки, группы или `<OverriddenByRibbonApi>true</OverriddenByRibbonApi>` меню отмечены, то это не видно, и все это ребенка разметки игнорируется, когда пользовательские контекстуальные вкладки не поддерживаются. Таким образом, не имеет значения, если какой-либо из этих элементов ребенка `<OverriddenByRibbonApi>` элемент или то, что его значение. Смысл этого заключается в том, что если элемент меню, элемент управления или группа должны быть видны во всех контекстах, то не только он не должен быть отмечен `<OverriddenByRibbonApi>true</OverriddenByRibbonApi>` , но *его родоначальницы меню, группы и вкладки также не должны быть отмечены таким образом*.

> [!IMPORTANT]
> Не *помекайте* все элементы ребенка вкладкой, группой или `<OverriddenByRibbonApi>true</OverriddenByRibbonApi>` меню. Это бессмысленно, если родительский элемент помечен по `<OverriddenByRibbonApi>true</OverriddenByRibbonApi>` причинам, уявечаемым в предыдущем пункте. Кроме того, если вы `<OverriddenByRibbonApi>` оставите на родителей (или установить `false` его), то родитель появится независимо от того, пользовательские контекстуальные вкладки поддерживаются, но он будет пуст, когда они поддерживаются. Таким образом, если все элементы ребенка не должны отображаться при поддержке пользовательских контекстуальных вкладок, отметь родительский и только `<OverriddenByRibbonApi>true</OverriddenByRibbonApi>` родительский.

#### <a name="use-apis-that-show-or-hide-a-task-pane-in-specified-contexts"></a>Используйте API, которые показывают или скрывают панели задач в определенных контекстах

В качестве `<OverriddenByRibbonApi>` альтернативы, ваше дополнение может определить панели задач с пользовательским интерфейсом элементов управления, которые дублируют функциональность элементов управления на пользовательских контекстуальных вкладку. Затем используйте [методы Office.addin.showAsTaskpane](/javascript/api/office/office.addin?view=common-js&preserve-view=true#showAsTaskpane__) [и Office.addin.hide,](/javascript/api/office/office.addin?view=common-js&preserve-view=true#hide__) чтобы показать панели задач, когда и только когда контекстуальная вкладка была бы показана, если бы она была поддержана. Для получения подробной информации о том, как использовать [эти методы, см. Показать или скрыть панели задач Office add-in.](../develop/show-hide-add-in.md)

### <a name="handle-the-hostrestartneeded-error"></a>Ручка HostRestartNeededed ошибка

В некоторых случаях Office не может обновить ленту и возвращает ошибку. Например, если после обновления у надстройки другой набор настраиваемых команд, приложение Office необходимо закрыть и снова открыть. Пока это действие не будет выполнено, метод `requestUpdate` будет возвращать ошибку `HostRestartNeeded`. Ваш код должен обрабатывать эту ошибку. Ниже приводится пример того, как. В этом случае метод `reportError` выводит сообщение об ошибке для пользователя.

```javascript
function showDataTab() {
    try {
        Office.ribbon.requestUpdate({
            tabs: [
                {
                    id: "CtxTab1",
                    visible: true
                }
            ]});
    }
    catch(error) {
        if (error.code == "HostRestartNeeded"){
            reportError("Contoso Awesome Add-in has been upgraded. Please save your work, then close and reopen the Office application.");
        }
    }
}
```
